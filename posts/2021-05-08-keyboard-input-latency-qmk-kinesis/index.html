<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Measure and reduce keyboard input latency with QMK on the Kinesis Advantage - Michael Stapelberg</title>

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="shortcut icon" href="/favicon.ico" />
  <meta name="description" content="Over the last few years, I worked on a few projects around keyboard input latency:
In 2018, I introduced the kinX keyboard controller with 0.2ms of input latency.
In 2020, I introduced the kinT keyboard controller, which works with a wide range of Teensy micro controllers, and both the old KB500 and the newer KB600 Kinesis Advantage models.">
  <link rel="canonical" href="https://michael.stapelberg.ch/posts/2021-05-08-keyboard-input-latency-qmk-kinesis/">
  <meta name="author" content="Michael Stapelberg">
  <style type="text/css">
    @font-face {
	font-family: 'Roboto Mono';
	src: url('/font/subset-RobotoMono-Regular.eot');
	src: local('Roboto Mono Regular'), local('RobotoMono-Regular'),
        url('/font/subset-RobotoMono-Regular.eot?#iefix') format('embedded-opentype'),
        url('/font/subset-RobotoMono-Regular.woff2') format('woff2'),
        url('/font/subset-RobotoMono-Regular.woff') format('woff'),
        url('/font/subset-RobotoMono-Regular.ttf') format('truetype');
	font-weight: normal;
	font-style: normal;
	font-display: swap;
    }

    @font-face {
	font-family: 'Roboto';
	src: url('/font/subset-Roboto-Bold.eot');
	src: local('Roboto Bold'), local('Roboto-Bold'),
        url('/font/subset-Roboto-Bold.eot?#iefix') format('embedded-opentype'),
        url('/font/subset-Roboto-Bold.woff2') format('woff2'),
        url('/font/subset-Roboto-Bold.woff') format('woff'),
        url('/font/subset-Roboto-Bold.ttf') format('truetype');
	font-weight: bold;
	font-style: normal;
	font-display: swap;
    }

    @font-face {
	font-family: 'Roboto';
	src: url('/font/subset-Roboto-Regular.eot');
	src: local('Roboto'), local('Roboto-Regular'),
        url('/font/subset-Roboto-Regular.eot?#iefix') format('embedded-opentype'),
        url('/font/subset-Roboto-Regular.woff2') format('woff2'),
        url('/font/subset-Roboto-Regular.woff') format('woff'),
        url('/font/subset-Roboto-Regular.ttf') format('truetype');
	font-weight: normal;
	font-style: normal;
	font-display: swap;
    }

    @font-face {
	font-family: 'Lato';
	src: url('/font/subset-Lato-Bold.eot');
	src: local('Lato Bold'), local('Lato-Bold'),
        url('/font/subset-Lato-Bold.eot?#iefix') format('embedded-opentype'),
        url('/font/subset-Lato-Bold.woff2') format('woff2'),
        url('/font/subset-Lato-Bold.woff') format('woff'),
        url('/font/subset-Lato-Bold.ttf') format('truetype');
	font-weight: bold;
	font-style: normal;
	font-display: swap;
    }

    body, td, th {
	font-family: 'Roboto';
	font-size: 16px;
	line-height: 150%;
	color: #000;
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
	font-family: 'Lato';
	font-weight: bold;
	font-variant-ligatures: none;
	color: #000;
    }
  </style>

  
  <link rel="preload" href="/font/subset-Lato-Bold.woff2" as="font" type="font/woff2" crossorigin>
  <link rel="preload" href="/font/subset-Roboto-Regular.woff2" as="font" type="font/woff2" crossorigin>
  
  <link rel="stylesheet" href="/1.min.css" type="text/css">
  <link rel="alternate" href="/feed.xml" type="application/atom+xml" title="ATOM feed">
</head>
<body>



<header id="ms_navbar">
  <a href="/">
<img
    src="/logo1x.jpg"
    srcset="/logo2x.jpg 2x, /logo3x.jpg 3x"
    width="42"
    height="52"
    alt="profile picture"
    title="profile picture">
</a>
  <div>
    <a href="/"><h1>Michael Stapelberg</h1></a>
    <nav id="ms_desktopnav">
      <ul>
	
    <li><a href="/" >About</a></li>
    <li><a href="/posts/" class="active">Blog</a></li>
    <li><a href="/talks/" >Talks</a></li>
    <li><a href="/series/" >Series</a></li>

      </ul>
    </nav>
  </div>

  <div id="ms_burger_open">
    <label for="ms_burger"><svg viewBox="0 0 100 80" width="24" height="24">
	<rect width="100" height="17" rx="8" fill="white"></rect>
	<rect y="30" width="100" height="17" rx="8" fill="white"></rect>
	<rect y="60" width="100" height="17" rx="8" fill="white"></rect>
    </svg></label>
  </div>

  <input type="checkbox" id="ms_burger">

  <nav id="ms_navdrawer">
    <div id="ms_navdrawer_top">
      <div id="ms_navdrawer_search">
	<a href="/">
<img
    src="/logo1x.jpg"
    srcset="/logo2x.jpg 2x, /logo3x.jpg 3x"
    width="42"
    height="52"
    alt="profile picture"
    title="profile picture">

	<h1>Michael Stapelberg</h1></a>
      </div>
      <div id="ms_burger_close">
	<label for="ms_burger"><svg viewBox="0 0 110 110" width="24" height="24">
	    <line x1="10" y1="10" x2="100" y2="100" stroke="#047bc2" stroke-width="20" />
	    <line x1="100" y1="10" x2="10" y2="100" stroke="#047bc2" stroke-width="20" />
	</svg></label>
      </div>
    </div>

    <div id="ms_navdrawer_content">
      <ul>
	
    <li><a href="/" >About</a></li>
    <li><a href="/posts/" class="active">Blog</a></li>
    <li><a href="/talks/" >Talks</a></li>
    <li><a href="/series/" >Series</a></li>

      </ul>
    </div>
  </nav>
</header>
<main>
      <div><h1 class="ms_title">Measure and reduce keyboard input latency with QMK on the Kinesis Advantage</h1>

<div class="ms_meta">
  <div id="ms_date">published 2021-05-08</div>
  
  
  <div>
    <a href="https://github.com/stapelberg/hugo/edit/master/content/posts/2021-05-08-keyboard-input-latency-qmk-kinesis/index.markdown"><img src="/Bilder/pen-square-solid.svg" width="18" height="20" alt="Edit Icon" title="Suggest a change to this article"></a>
  </div>
  
  <div>
    <a href="https://twitter.com/zekjur/status/1391031601182695426"><img src="/Bilder/twitter-brands.svg" width="18" height="18" alt="Twitter icon" title="Discuss this article on Twitter!"></a>
  </div>
  
</div>
<div class="Artikel" id="content">
  <style type="text/css">
    .TableOfContents > ul, .TableOfContents > ul > li > ul {
	list-style: none;
	margin: 0;
	padding: 0;
    }
    .TableOfContents li {
	margin-bottom: 1rem;
    }
  </style>
  <details class="ms_toc_details">
    <summary>Table of contents</summary>
    <nav class="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#measurement-setup">Measurement setup</a>
<ul>
<li><a href="#enable-the-debug-console-in-qmk">Enable the debug console in QMK</a></li>
<li><a href="#finding-the-pins">Finding the pins</a></li>
<li><a href="#eagercaps">Eager Caps Lock LED</a></li>
<li><a href="#host-side-linux">Host side (Linux)</a></li>
<li><a href="#code-to-simulate-key-presses-and-take-measurements">Code to simulate key presses and take measurements</a></li>
<li><a href="#running-measurements">Running measurements</a></li>
<li><a href="#scantoscandelay">Scan-to-scan delay</a></li>
</ul></li>
<li><a href="#measurement-harness">Measurement harness</a>
<ul>
<li><a href="#kint36-kint41-gpio">kint36, kint41: GPIO</a></li>
<li><a href="#kint2pp-5v">kint2pp: 5V</a></li>
<li><a href="#kinx-fpc">kinX: FPC</a></li>
<li><a href="#original-kinesis-controller">Original Kinesis controller</a></li>
</ul></li>
<li><a href="#qmk-input-latency">QMK input latency</a>
<ul>
<li><a href="#eagerdebounce">Eager debounce</a></li>
<li><a href="#quickusbpolling">Quicker USB polling interval</a></li>
<li><a href="#fastmatrixscan">Faster matrix scan</a></li>
<li><a href="#shortsleeps">Shorter sleeps</a></li>
</ul></li>
<li><a href="#results">Results</a>
<ul>
<li><a href="#kint41">kint41</a></li>
<li><a href="#kinx">kinX</a></li>
<li><a href="#original-kinesis">Original Kinesis</a></li>
</ul></li>
<li><a href="#conclusion">Conclusion</a></li>
<li><a href="#appendix-a-isitsnappy">Appendix A: isitsnappy</a></li>
<li><a href="#appendixb">Appendix B: USB polling interval (device side)</a></li>
</ul></li>
</ul>
</nav>
  </details>
  

<p>Over the last few years, I worked on a few projects around keyboard input latency:</p>

<p>In 2018, I introduced the <a href="/posts/2018-04-17-kinx/">kinX keyboard controller with 0.2ms of input
latency</a>.</p>

<p>In 2020, I introduced the <a href="/posts/2020-07-09-kint-kinesis-keyboard-controller/">kinT keyboard
controller</a>, which works
with a wide range of Teensy micro controllers, and both the old KB500 and the
newer KB600 Kinesis Advantage models.</p>

<p>While the 2018 kinX controller had built-in latency measurement, I was starting
from scratch with the kinT design, where I wanted to use the QMK keyboard
firmware instead of my own firmware.</p>

<p>That got me thinking: instead of adjusting the firmware to self-report latency
numbers, is there a way we can do latency measurements externally, ideally
without software changes?</p>

<p>This article walks you through how to set up a measurement environment for your
keyboard controller’s input latency, be it original or self-built. I’ll use a
Kinesis Advantage keyboard, but this approach should generalize to all
keyboards.</p>

<p>I will explain a few common causes for extra keyboard input latency and show you
how to fix them in the QMK keyboard firmware.</p>

<h2 id="measurement-setup">Measurement setup</h2>

<p>The idea is to connect a <a href="https://www.pjrc.com/store/teensy40.html">Teensy 4.0</a>
(or similar), which simulates pressing the Caps Lock key and measures the
duration until the keypress resulted in a Caps Lock LED change.</p>

<p>We use the Caps Lock key because it is one of the few keys that results in an
LED change.</p>

<p>Here you can see the Teensy 4.0 connected to the <a href="https://github.com/kinx-project/kint/">kinT
controller</a>, connected to a laptop:</p>
















<a href="https://michael.stapelberg.ch/posts/2021-05-08-keyboard-input-latency-qmk-kinesis/endtoend_measure_featured.jpg"><img
  srcset="https://michael.stapelberg.ch/posts/2021-05-08-keyboard-input-latency-qmk-kinesis/endtoend_measure_featured_hu855bbe0a9c47ac557e5b09db74fa3b06_1237431_1200x0_resize_q75_box.jpg 2x,https://michael.stapelberg.ch/posts/2021-05-08-keyboard-input-latency-qmk-kinesis/endtoend_measure_featured_hu855bbe0a9c47ac557e5b09db74fa3b06_1237431_1800x0_resize_q75_box.jpg 3x"
  src="https://michael.stapelberg.ch/posts/2021-05-08-keyboard-input-latency-qmk-kinesis/endtoend_measure_featured_hu855bbe0a9c47ac557e5b09db74fa3b06_1237431_600x0_resize_q75_box.jpg"
  alt="measurement setup" title="measurement setup"
  width="600"
  height="450"
  style="border: 1px solid #000"
  
  loading="lazy"></a>




<h3 id="enable-the-debug-console-in-qmk">Enable the debug console in QMK</h3>

<p>Let’s get our QMK working copy ready for development! I like to work in a
separate QMK working copy per project:</p>

<pre><code>% docker run -it -v $PWD:/usr/src archlinux
# pacman -Sy &amp;&amp; pacman -S qmk make which diffutils
# cd /usr/src
# qmk clone -b develop qmk/qmk_firmware $PWD/qmk-input-latency
# cd qmk-input-latency
</code></pre>

<p>I compile the firmware for my keyboard like so:</p>

<pre><code># make kinesis/kint36:stapelberg
</code></pre>

<p>To enable the debug console, I need to edit my QMK keymap <code>stapelberg</code> by
updating <code>keyboards/kinesis/keymaps/stapelberg/rules.mk</code> to contain:</p>

<pre><code>CONSOLE_ENABLE = yes
</code></pre>

<p>After compiling and flashing the firmware, the <code>hid_listen</code> tool will detect the
device and listen for QMK debug messages:</p>

<pre><code>% sudo hid_listen
Waiting for device:...
Listening:
</code></pre>

<h3 id="finding-the-pins">Finding the pins</h3>

<p>Let’s locate the Caps Lock key’s corresponding row and column in our keyboard matrix!</p>

<p>We can make QMK show which keys are recognized after each scan by adding to
<code>keyboards/kinesis/keymaps/stapelberg/keymap.c</code> the following code:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#902000">void</span> <span style="color:#06287e">keyboard_post_init_user</span>() {
  debug_config.enable <span style="color:#666">=</span> <span style="color:#007020">true</span>;
  debug_config.matrix <span style="color:#666">=</span> <span style="color:#007020">true</span>;
}</code></pre></div>
<p>Now we’ll see in the <code>hid_listen</code> output which key is active when pressing Caps Lock:</p>

<pre><code>r/c 01234567
00: 00100000
01: 00000000
[…]
</code></pre>

<p>For our kinT controller, Caps Lock is on QMK matrix row 0, column 2.</p>

<p>In the <a href="https://github.com/kinx-project/kint/blob/master/schematic-v2021-04-25.pdf">kinT
schematic</a>,
the corresponding signals are <code>ROW_EQL</code> and <code>COL_2</code>.</p>

<p>To hook up the Teensy 4.0 latency measurement driver, I am making the following
GPIO connections to the kint36, kint41 or kint2pp (with voltage converter!)
keyboard controllers:</p>

<table>
<thead>
<tr>
<th>driver 4.0</th>
<th>signal</th>
<th>kint36, kint41</th>
<th>kint2pp (5V!)</th>
</tr>
</thead>

<tbody>
<tr>
<td>GND</td>
<td><code>GND</code></td>
<td>GND</td>
<td>GND</td>
</tr>

<tr>
<td>pin 10</td>
<td><code>ROW_EQL</code></td>
<td>pin 8</td>
<td>D7</td>
</tr>

<tr>
<td>pin 11</td>
<td><code>COL_2</code></td>
<td>pin 15</td>
<td>F7</td>
</tr>

<tr>
<td>pin 12</td>
<td><code>LED_CAPS_LOCK</code></td>
<td>pin 12</td>
<td>C1</td>
</tr>
</tbody>
</table>

<aside class="admonition note">
  <div class="note-container">
    <div class="note-icon">
      <svg id="exclamation-icon" width="100%" height="100%" viewBox="0 0 24 24" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:1.41421;">
    <path d="M0,0L24,0L24,24L0,24L0,0Z" style="fill:none;"/>
    <g transform="matrix(1.2,0,0,1.2,-2.4,-2.4)">
        <path d="M12,2C6.48,2 2,6.48 2,12C2,17.52 6.48,22 12,22C17.52,22 22,17.52 22,12C22,6.48 17.52,2 12,2ZM13,17L11,17L11,15L13,15L13,17ZM13,13L11,13L11,7L13,7L13,13Z" style="fill-rule:nonzero;"/>
    </g>
</svg>

    </div>
    <div class="admonition-content"><strong>Note:</strong> Unfortunately, the signals are not available on the Teensy 4.x dev kit
<a href="https://www.nxp.com/design/development-boards/i-mx-evaluation-and-development-boards/mimxrt1060-evk-i-mx-rt1060-evaluation-kit:MIMXRT1060-EVK">NXP i.MX RT1060 Evaluation Kit
(<code>MIMXRT1060-EVK</code>)</a>. Here,
pin 8 (<code>B1_00</code>) is used for the LVDI interface instead.</div>
  </div>
</aside>


<h3 id="eagercaps">Eager Caps Lock LED</h3>

<p>When the host signals to the keyboard that Caps Lock is now turned on, the QMK
firmware first updates a flag in the USB interrupt handler, but only updates the
Caps Lock LED pin after the next matrix scan has completed.</p>

<p>This is fine in normal usage, but our measurement readings will get more precise
if we immediately update the Caps Lock LED pin. We can do this in
<code>set_led_transfer_cb</code> in <code>tmk_core/protocol/chibios/usb_main.c</code>, which is called
from the USB interrupt handler:</p>

<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#007020">#include</span> <span style="color:#007020">&#34;gpio.h&#34;</span><span style="color:#007020">
</span><span style="color:#007020"></span>
<span style="color:#007020;font-weight:bold">static</span> <span style="color:#902000">void</span> <span style="color:#06287e">set_led_transfer_cb</span>(USBDriver <span style="color:#666">*</span>usbp) {
    <span style="color:#007020;font-weight:bold">if</span> (usbp<span style="color:#666">-&gt;</span>setup[<span style="color:#40a070">6</span>] <span style="color:#666">==</span> <span style="color:#40a070">2</span>) { <span style="color:#60a0b0;font-style:italic">/* LSB(wLength) */</span>
        uint8_t report_id <span style="color:#666">=</span> set_report_buf[<span style="color:#40a070">0</span>];
        <span style="color:#007020;font-weight:bold">if</span> ((report_id <span style="color:#666">==</span> REPORT_ID_KEYBOARD) <span style="color:#666">||</span> (report_id <span style="color:#666">==</span> REPORT_ID_NKRO)) {
            keyboard_led_state <span style="color:#666">=</span> set_report_buf[<span style="color:#40a070">1</span>];
        }
    } <span style="color:#007020;font-weight:bold">else</span> {
        keyboard_led_state <span style="color:#666">=</span> set_report_buf[<span style="color:#40a070">0</span>];
    }
<span style="display:block;width:100%;background-color:#d8d8d8">    <span style="color:#007020;font-weight:bold">if</span> ((keyboard_led_state <span style="color:#666">&amp;</span> <span style="color:#40a070">2</span>) <span style="color:#666">!=</span> <span style="color:#40a070">0</span>) {
</span><span style="display:block;width:100%;background-color:#d8d8d8">      writePinLow(C7); <span style="color:#60a0b0;font-style:italic">// turn on CAPS_LOCK LED
</span></span><span style="display:block;width:100%;background-color:#d8d8d8"><span style="color:#60a0b0;font-style:italic"></span>    } <span style="color:#007020;font-weight:bold">else</span> {
</span><span style="display:block;width:100%;background-color:#d8d8d8">      writePinHigh(C7); <span style="color:#60a0b0;font-style:italic">// turn off CAPS_LOCK LED
</span></span><span style="display:block;width:100%;background-color:#d8d8d8"><span style="color:#60a0b0;font-style:italic"></span>    }
</span>}</code></pre></div>

<h3 id="host-side-linux">Host side (Linux)</h3>

<p>On the USB host, i.e. the Linux computer, I switch to a <a href="https://en.wikipedia.org/wiki/Virtual_console">Virtual Terminal
(VT)</a> by stopping my login
manager (killing my current graphical session!):</p>

<pre><code>% sudo systemctl stop gdm
</code></pre>

<p>With the Virtual Terminal active, we know that the Caps Lock key press will be
handled entirely in kernel driver code without having to round-trip to
userspace.</p>

<p>We can verify this by collecting stack traces with <a href="https://manpages.debian.org/bpftrace.8"><code>bpftrace(8)</code></a>
 when the kernel executes the <a href="https://elixir.bootlin.com/linux/v5.12/source/drivers/tty/vt/keyboard.c#L1521"><code>kbd_event</code> function in
<code>drivers/tty/vt</code></a>:</p>

<pre><code>% sudo bpftrace -e 'kprobe:kbd_event { @[kstack] = count(); }'
</code></pre>

<p>After pressing Caps Lock and cancelling the <code>bpftrace</code> process, you should see a
stack trace.</p>

<p>I then measured the baseline end-to-end latency, using <a href="https://github.com/kinx-project/measure-fw">my <code>measure-fw</code>
firmware</a> running on the FRDM-K66F
eval kit, a cheap and widely available USB 2.0 High Speed device. The firmware
measures the latency between a button press and the USB HID report for the Caps
Lock LED, but without any additional matrix scanning delay or similar:</p>

<pre><code>% cat /dev/ttyACM0
sof=74 μs	report=393 μs
sof=42 μs	report=512 μs
sof=19 μs	report=512 μs
sof=39 μs	report=488 μs
sof=20 μs	report=518 μs
sof=90 μs	report=181 μs
sof=42 μs	report=389 μs
sof=7 μs	report=319 μs
</code></pre>

<p>This is the quickest reaction we can get out of this computer. Anything on top
(e.g. X11, application) will be slower, so this measurement establishes a lower
bound.</p>

<h3 id="code-to-simulate-key-presses-and-take-measurements">Code to simulate key presses and take measurements</h3>

<p>I’m running the <a href="https://github.com/kinx-project/latencydriver">latencydriver Arduino
sketch</a>, with the Arduino IDE
configured for:</p>

<p>Teensy 4.0 (USB Type: Serial, CPU Speed: 600 MHz, Optimize: Faster)</p>

<p>Here’s how we set up the pins in the measurement driver Teensy 4.0:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#902000">void</span> <span style="color:#06287e">setup</span>() {
  Serial.begin(<span style="color:#40a070">9600</span>);

  <span style="color:#60a0b0;font-style:italic">// Connected to kinT pin 15, COL_2
</span><span style="color:#60a0b0;font-style:italic"></span>  pinMode(<span style="color:#40a070">11</span>, OUTPUT);
  digitalWrite(<span style="color:#40a070">11</span>, HIGH);

  <span style="color:#60a0b0;font-style:italic">// Connected to kinT pin 8, ROW_EQL.
</span><span style="color:#60a0b0;font-style:italic"></span>  <span style="color:#60a0b0;font-style:italic">// Pin 11 will be high/low in accordance with pin 10
</span><span style="color:#60a0b0;font-style:italic"></span>  <span style="color:#60a0b0;font-style:italic">// to simulate a key-press, and always high (unpressed)
</span><span style="color:#60a0b0;font-style:italic"></span>  <span style="color:#60a0b0;font-style:italic">// otherwise.
</span><span style="color:#60a0b0;font-style:italic"></span>  pinMode(<span style="color:#40a070">10</span>, INPUT_PULLDOWN);
  attachInterrupt(digitalPinToInterrupt(<span style="color:#40a070">10</span>), onScan, CHANGE);

  <span style="color:#60a0b0;font-style:italic">// Connected to the kinT LED_CAPS_LOCK output:
</span><span style="color:#60a0b0;font-style:italic"></span>  pinMode(<span style="color:#40a070">12</span>, INPUT_PULLDOWN);
  attachInterrupt(digitalPinToInterrupt(<span style="color:#40a070">12</span>), onCapsLockLED, CHANGE);
}</code></pre></div>
<p>In order to make a key read as pressed, we need to connect the column with the
row in the keyboard matrix, but only when the column is scanned. We do that in
the interrupt handler like so:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#902000">bool</span> simulate_press <span style="color:#666">=</span> <span style="color:#007020">false</span>;

<span style="color:#902000">void</span> <span style="color:#06287e">onScan</span>() {
  <span style="color:#007020;font-weight:bold">if</span> (simulate_press) {
    <span style="color:#60a0b0;font-style:italic">// connect row scan signal with column read
</span><span style="color:#60a0b0;font-style:italic"></span>    digitalWrite(<span style="color:#40a070">11</span>, digitalRead(<span style="color:#40a070">10</span>));
  } <span style="color:#007020;font-weight:bold">else</span> {
    <span style="color:#60a0b0;font-style:italic">// always read not pressed otherwise
</span><span style="color:#60a0b0;font-style:italic"></span>    digitalWrite(<span style="color:#40a070">11</span>, HIGH);
  }
}</code></pre></div>
<p>In our text interface, we can now start a measurement like so:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">caps_lock_on_to_off <span style="color:#666">=</span> capsLockOn();
Serial.printf(<span style="color:#4070a0">&#34;# Caps Lock key pressed (transition: %s)</span><span style="color:#4070a0;font-weight:bold">\r\n</span><span style="color:#4070a0">&#34;</span>,
  caps_lock_on_to_off <span style="color:#666">?</span> <span style="color:#4070a0">&#34;on to off&#34;</span> <span style="color:#666">:</span> <span style="color:#4070a0">&#34;off to on&#34;</span>);
simulate_press <span style="color:#666">=</span> <span style="color:#007020">true</span>;
t0 <span style="color:#666">=</span> ARM_DWT_CYCCNT;
emt0 <span style="color:#666">=</span> <span style="color:#40a070">0</span>;
eut0 <span style="color:#666">=</span> <span style="color:#40a070">0</span>;</code></pre></div>
<p>The next keyboard matrix scan will detect the key as pressed, send the HID
report to the OS, and when the OS responds with its HID report containing the
Caps Lock LED status, our Caps Lock LED interrupt handler is called to finish
the measurement:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#902000">void</span> <span style="color:#06287e">onCapsLockLED</span>() {
  <span style="color:#007020;font-weight:bold">const</span> uint32_t t1 <span style="color:#666">=</span> ARM_DWT_CYCCNT;
  <span style="color:#007020;font-weight:bold">const</span> uint32_t elapsed_millis <span style="color:#666">=</span> emt0;
  <span style="color:#007020;font-weight:bold">const</span> uint32_t elapsed_micros <span style="color:#666">=</span> eut0;
  uint32_t elapsed_nanos <span style="color:#666">=</span> (t1 <span style="color:#666">-</span> t0) <span style="color:#666">/</span> cycles_per_ns;

  Serial.printf(<span style="color:#4070a0">&#34;# Caps Lock LED (pin 12) is now %s</span><span style="color:#4070a0;font-weight:bold">\r\n</span><span style="color:#4070a0">&#34;</span>, capsLockOn() <span style="color:#666">?</span> <span style="color:#4070a0">&#34;on&#34;</span> <span style="color:#666">:</span> <span style="color:#4070a0">&#34;off&#34;</span>);
  Serial.printf(<span style="color:#4070a0">&#34;# %u ms == %u us</span><span style="color:#4070a0;font-weight:bold">\r\n</span><span style="color:#4070a0">&#34;</span>, elapsed_millis, elapsed_micros);
  Serial.printf(<span style="color:#4070a0">&#34;BenchmarkKeypressToLEDReport 1 %u ns/op</span><span style="color:#4070a0;font-weight:bold">\r\n</span><span style="color:#4070a0">&#34;</span>, elapsed_nanos);
  Serial.printf(<span style="color:#4070a0">&#34;</span><span style="color:#4070a0;font-weight:bold">\r\n</span><span style="color:#4070a0">&#34;</span>);
}</code></pre></div>
<h3 id="running-measurements">Running measurements</h3>

<p>Connect the Teensy 4.0 to your computer and open its USB serial console:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">% screen /dev/ttyACM0 <span style="color:#40a070">115200</span></code></pre></div>
<p>You should be greeted by a welcome message:</p>

<pre><code># kinT latency measurement driver
#   t  - trigger measurement
</code></pre>

<p>To save your measurements to file, use <code>C-a H</code> in <code>screen</code> to make it write to
file <code>screenlog.0</code>.</p>

<p>Press <code>t</code> a few times to trigger a few measurements and close <code>screen</code> using
<code>C-a k</code>.</p>

<p>You can summarize the measurements using
<a href="https://pkg.go.dev/golang.org/x/perf/cmd/benchstat"><code>benchstat</code></a>:</p>

<pre><code>% benchstat screenlog.0
name                 time/op
KeypressToLEDReport  1.82ms ±20%
</code></pre>

<h3 id="scantoscandelay">Scan-to-scan delay</h3>

<p>The measurement output on the USB serial console also contains the matrix
scan-to-scan delay:</p>

<pre><code># scan-to-scan delay: 422475 ns
</code></pre>

<p>Each keyboard matrix scan turns on each row one-by-one, then reads all the columns.</p>

<p>This means that in each matrix scan, <code>ROW_EQL</code> will be set high once, then low again.</p>

<p>The Teensy 4.0 measures scan-to-scan delay by timing the activations of
<code>ROW_EQL</code>.</p>

<p>We can verify this approach by making QMK self-report its scan rate. Enable the
matrix scan rate debug option in <code>keyboards/kinesis/keymaps/stapelberg/config.h</code>
like so:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#007020">#pragma once
</span><span style="color:#007020"></span>
<span style="color:#007020">#define DEBUG_MATRIX_SCAN_RATE</span></code></pre></div>
<p>Using <code>hid_listen</code> we can now see the following QMK debug messages:</p>

<pre><code>% sudo hid_listen
Waiting for new device:..
Listening:
matrix scan frequency: 2300
matrix scan frequency: 2367
matrix scan frequency: 2367
</code></pre>

<p>A matrix scan rate/frequency of 2367 scans per second corresponds to 422μs per
scan:</p>

<pre><code>1000000 μs / 2367 scans/second = 422μs
</code></pre>

<p>Yet another way of verifying the approach is by short-circuiting an end-to-end
measurement with a one-line change in our QMK keyboard code:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#902000">bool</span> <span style="color:#06287e">process_action_kb</span>(keyrecord_t <span style="color:#666">*</span>record) {
<span style="color:#007020">#define LED_CAPS_LOCK LINE_PIN12
</span><span style="color:#007020">#define ledTurnOn writePinLow
</span><span style="color:#007020"></span>  ledTurnOn(LED_CAPS_LOCK);
  <span style="color:#007020;font-weight:bold">return</span> <span style="color:#007020">true</span>;
}</code></pre></div>
<p>Repeating the measurements, this gives us:</p>

<pre><code>% benchstat screenlog.0     
name                 time/op
KeypressToLEDReport  693µs ±26%
</code></pre>

<p>This value is between [0, 2 * 422μs] because a key might be pressed
after it was already scanned by the in-progress matrix scan, meaning it will
need to wait until the next scan completed (!) before it can be registered as
pressed.</p>

<h2 id="measurement-harness">Measurement harness</h2>

<p>Now that we have our general measurement environment all set up, it’s time to
connect our Teensy 4.0 to a few different keyboard controllers!</p>

<h3 id="kint36-kint41-gpio">kint36, kint41: GPIO</h3>

<p>If you have an un-soldered micro controller you want to measure, setup is easy:
just connect all GPIOs to the Teensy 4.0 latency test driver directly! I’m using
this for the <code>kint36</code> and <code>kint41</code>:</p>
















<a href="https://michael.stapelberg.ch/posts/2021-05-08-keyboard-input-latency-qmk-kinesis/kint41_gpio_measure.jpg"><img
  srcset="https://michael.stapelberg.ch/posts/2021-05-08-keyboard-input-latency-qmk-kinesis/kint41_gpio_measure_hu855bbe0a9c47ac557e5b09db74fa3b06_607037_1200x0_resize_q75_box.jpg 2x,https://michael.stapelberg.ch/posts/2021-05-08-keyboard-input-latency-qmk-kinesis/kint41_gpio_measure_hu855bbe0a9c47ac557e5b09db74fa3b06_607037_1800x0_resize_q75_box.jpg 3x"
  src="https://michael.stapelberg.ch/posts/2021-05-08-keyboard-input-latency-qmk-kinesis/kint41_gpio_measure_hu855bbe0a9c47ac557e5b09db74fa3b06_607037_600x0_resize_q75_box.jpg"
  alt="GPIO measurement" title="GPIO measurement"
  width="600"
  height="329"
  style="border: 1px solid #000"
  
  loading="lazy"></a>




<p>(build in <code>/home/michael/kinx/kintpp/rebased</code>, last results in <code>screenlog-kint36-eager-caps.0</code>)</p>

<h3 id="kint2pp-5v">kint2pp: 5V</h3>

<p>Because the Teensy++ uses 5V logic levels, we need to convert the levels from/to
3.3V. This is easily done using e.g. the <a href="https://www.sparkfun.com/products/12009">SparkFun Logic Level Converter
(Bi-Directional)</a> on a breadboard:</p>
















<a href="https://michael.stapelberg.ch/posts/2021-05-08-keyboard-input-latency-qmk-kinesis/kint2pp_levelshifter.jpg"><img
  srcset="https://michael.stapelberg.ch/posts/2021-05-08-keyboard-input-latency-qmk-kinesis/kint2pp_levelshifter_hua983c5221b9326c29ab4450c04cd6d00_1691385_1200x0_resize_q75_box.jpg 2x,https://michael.stapelberg.ch/posts/2021-05-08-keyboard-input-latency-qmk-kinesis/kint2pp_levelshifter_hua983c5221b9326c29ab4450c04cd6d00_1691385_1800x0_resize_q75_box.jpg 3x"
  src="https://michael.stapelberg.ch/posts/2021-05-08-keyboard-input-latency-qmk-kinesis/kint2pp_levelshifter_hua983c5221b9326c29ab4450c04cd6d00_1691385_600x0_resize_q75_box.jpg"
  alt="kint2pp with level shifter" title="kint2pp with level shifter"
  width="600"
  height="800"
  style="border: 1px solid #000"
  
  loading="lazy"></a>




<h3 id="kinx-fpc">kinX: FPC</h3>

<p>But what if you have a design where the micro controller doesn’t come
standalone, only soldered to a keyboard controller board, such as my earlier
kinX controller?</p>

<p>You can use a spare FPC connector (<a href="https://octopart.com/39-53-2135-molex-7670149?r=sp">Molex
39-53-2135</a>) and solder
jumper wires to the pins for <code>COL_2</code> and <code>ROW_EQL</code>. For Caps Lock and Ground,
I soldered jumper wires to the board:</p>
















<a href="https://michael.stapelberg.ch/posts/2021-05-08-keyboard-input-latency-qmk-kinesis/kinx_fpc_measure.jpg"><img
  srcset="https://michael.stapelberg.ch/posts/2021-05-08-keyboard-input-latency-qmk-kinesis/kinx_fpc_measure_hu855bbe0a9c47ac557e5b09db74fa3b06_1315352_1200x0_resize_q75_box.jpg 2x,https://michael.stapelberg.ch/posts/2021-05-08-keyboard-input-latency-qmk-kinesis/kinx_fpc_measure_hu855bbe0a9c47ac557e5b09db74fa3b06_1315352_1800x0_resize_q75_box.jpg 3x"
  src="https://michael.stapelberg.ch/posts/2021-05-08-keyboard-input-latency-qmk-kinesis/kinx_fpc_measure_hu855bbe0a9c47ac557e5b09db74fa3b06_1315352_600x0_resize_q75_box.jpg"
  alt="kinX measurement" title="kinX measurement"
  width="600"
  height="450"
  style="border: 1px solid #000"
  
  loading="lazy"></a>




<aside class="admonition note">
  <div class="note-container">
    <div class="note-icon">
      <svg id="exclamation-icon" width="100%" height="100%" viewBox="0 0 24 24" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:1.41421;">
    <path d="M0,0L24,0L24,24L0,24L0,0Z" style="fill:none;"/>
    <g transform="matrix(1.2,0,0,1.2,-2.4,-2.4)">
        <path d="M12,2C6.48,2 2,6.48 2,12C2,17.52 6.48,22 12,22C17.52,22 22,17.52 22,12C22,6.48 17.52,2 12,2ZM13,17L11,17L11,15L13,15L13,17ZM13,13L11,13L11,7L13,7L13,13Z" style="fill-rule:nonzero;"/>
    </g>
</svg>

    </div>
    <div class="admonition-content"><strong>Note:</strong> The
<a href="https://github.com/kinx-project/adapter-use-kb600-with-kb500-controller">adapter-use-kb600-with-kb500-controller</a>
unfortunately cannot be used for this purpose: the required pins are connected
to the ground plane.</div>
  </div>
</aside>


<h3 id="original-kinesis-controller">Original Kinesis controller</h3>

<p>But what if you don’t want to solder jumper wires directly to the board?</p>

<p>The least invasive method is to connect the FPC connector break-out, and hold
probe heads onto the contacts while doing your measurements:</p>
















<a href="https://michael.stapelberg.ch/posts/2021-05-08-keyboard-input-latency-qmk-kinesis/kinesis_original_measure.jpg"><img
  srcset="https://michael.stapelberg.ch/posts/2021-05-08-keyboard-input-latency-qmk-kinesis/kinesis_original_measure_hu855bbe0a9c47ac557e5b09db74fa3b06_944081_1200x0_resize_q75_box.jpg 2x,https://michael.stapelberg.ch/posts/2021-05-08-keyboard-input-latency-qmk-kinesis/kinesis_original_measure_hu855bbe0a9c47ac557e5b09db74fa3b06_944081_1800x0_resize_q75_box.jpg 3x"
  src="https://michael.stapelberg.ch/posts/2021-05-08-keyboard-input-latency-qmk-kinesis/kinesis_original_measure_hu855bbe0a9c47ac557e5b09db74fa3b06_944081_600x0_resize_q75_box.jpg"
  alt="kinesis original controller measurement" title="kinesis original controller measurement"
  width="600"
  height="450"
  style="border: 1px solid #000"
  
  loading="lazy"></a>




<h2 id="qmk-input-latency">QMK input latency</h2>

<p>Now that the measurement hardware is set up, we can go through the code.</p>

<p>The following sections each cover one possible contributor to input latency.</p>

<h3 id="eagerdebounce">Eager debounce</h3>

<p>Key switches don’t generate a clean signal when pressed, instead they show a
ripple effect. Getting rid of this ripple is called
<a href="https://en.wiktionary.org/wiki/debounce">debouncing</a>, and every keyboard
firmware does it.</p>

<p>See <a href="https://beta.docs.qmk.fm/using-qmk/software-features/feature_debounce_type">QMK’s documentation on the Debounce
API</a>
for a good explanation of the differences between the different debounce approaches.</p>

<p>QMK’s default debounce algorithm <code>sym_defer_g</code> is chosen very cautiously. I
don’t know what the criteria are specifically for which types of key switches
suffer from noise and therefore need the <code>sym_defer_g</code> algorithm, but I know
that Cherry MX key switches with diodes like used in the Kinesis Advantage don’t
have noise and hence can use the other debounce algorithms, too.</p>

<p>While the default <code>sym_defer_g</code> debounce algorithm is robust, it also adds 5ms
of input latency:</p>

<pre><code>% benchstat screenlog-kint36.0
name                 time/op
KeypressToLEDReport  7.61ms ± 8%
</code></pre>

<p>For lower input latency, we need an <code>eager</code> algorithm. Specifically, I am
chosing the <code>sym_eager_pk</code> debounce algorithm by adding to my
<code>keyboards/kinesis/kint36/rules.mk</code>:</p>

<pre><code>DEBOUNCE_TYPE = sym_eager_pk
</code></pre>

<p>Now, the extra 5ms are gone:</p>

<pre><code>% benchstat screenlog-kint36-eager.0
name                 time/op
KeypressToLEDReport  2.12ms ±16%
</code></pre>

<p>Example change: <a href="https://github.com/qmk/qmk_firmware/pull/12626">https://github.com/qmk/qmk_firmware/pull/12626</a></p>

<h3 id="quickusbpolling">Quicker USB polling interval</h3>

<p>The USB host (computer) divides time into fixed-length segments called frames:</p>

<ul>
<li>USB Full Speed (USB 1.0) uses frames that are 1ms each.</li>
<li>USB High Speed (USB 2.0) introduces micro frames, which are 125μs.</li>
</ul>

<p>Each USB device specifies in its device descriptor how frequently (in frames)
the device should be polled. The <a href="https://en.wikipedia.org/wiki/USB_(Communications)#Transaction_latency">quickest polling
rate</a>
for USB 1.0 is 1 frame, meaning the device can send data after at most
1ms. Similarly, for USB 2.0, it’s 1 micro frame, i.e. send data every 125μs.</p>

<p>Of course, a quicker polling rate also means occupying resources on the USB bus
which are then no longer available to other devices. On larger USB hubs, this
might mean fewer devices can be used concurrently. The specifics of this
limitation depend on a lot of other factors, too. The polling rate plays a role,
in combination with the max. packet size and the number of endpoints.</p>

<p>Note that we are only talking about concurrent device usage, not about hogging
bandwidth: the bulk transfers that USB mass storage devices use are not any
slower in my tests. I achieve about 37 MiB/s with or without the kint41 USB 2.0
High Speed controller with <code>bInterval=1</code> present.</p>

<p>Even connecting two kint41 controllers at the same time still leaves enough
resources to use a Logitech C920 webcam in its most bandwidth-intensive pixel
format and resolution. The same cannot be said for e.g. NXP’s LPC-Link2 debug
probe.</p>

<aside class="admonition note">
  <div class="note-container">
    <div class="note-icon">
      <svg id="exclamation-icon" width="100%" height="100%" viewBox="0 0 24 24" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:1.41421;">
    <path d="M0,0L24,0L24,24L0,24L0,0Z" style="fill:none;"/>
    <g transform="matrix(1.2,0,0,1.2,-2.4,-2.4)">
        <path d="M12,2C6.48,2 2,6.48 2,12C2,17.52 6.48,22 12,22C17.52,22 22,17.52 22,12C22,6.48 17.52,2 12,2ZM13,17L11,17L11,15L13,15L13,17ZM13,13L11,13L11,7L13,7L13,13Z" style="fill-rule:nonzero;"/>
    </g>
</svg>

    </div>
    <div class="admonition-content"><strong>Open question:</strong> Would declaring multiple alternate settings in our USB device
descriptor dynamically reduce resource usage? Our keyboard could offer one
alternate setting with <code>bInterval=1</code> and one with <code>bInterval=10</code>.</div>
  </div>
</aside>


<p>To display the configured interval, the Linux kernel provides a debug pseudo file:</p>

<pre><code>% sudo cat /sys/kernel/debug/usb/devices

[…]
T:  Bus=01 Lev=02 Prnt=09 Port=02 Cnt=02 Dev#= 53 Spd=480  MxCh= 0
D:  Ver= 2.00 Cls=00(&gt;ifc ) Sub=00 Prot=00 MxPS=64 #Cfgs=  1
P:  Vendor=1209 ProdID=345c Rev= 0.01
S:  Manufacturer=&quot;https://github.com/stapelberg&quot;
S:  Product=&quot;kinT (kint41)&quot;
C:* #Ifs= 3 Cfg#= 1 Atr=a0 MxPwr=500mA
I:* If#= 0 Alt= 0 #EPs= 1 Cls=03(HID  ) Sub=01 Prot=01 Driver=usbhid
E:  Ad=81(I) Atr=03(Int.) MxPS=   8 Ivl=125us
I:* If#= 1 Alt= 0 #EPs= 1 Cls=03(HID  ) Sub=00 Prot=00 Driver=usbhid
E:  Ad=82(I) Atr=03(Int.) MxPS=  32 Ivl=125us
I:* If#= 2 Alt= 0 #EPs= 2 Cls=03(HID  ) Sub=00 Prot=00 Driver=usbhid
E:  Ad=83(I) Atr=03(Int.) MxPS=  32 Ivl=125us
E:  Ad=04(O) Atr=03(Int.) MxPS=  32 Ivl=125us
[…]
</code></pre>

<p>Alternatively, you can display the USB device descriptor using e.g. <code>sudo lsusb
-v -d 1209:345c</code> and interpret the <code>bInterval</code> setting yourself.</p>

<p>The above shows the best case: a USB 2.0 High Speed device (<code>Spd=480</code>) with
<code>bInterval=1</code> in its device descriptor (<code>Iv=125us</code>).</p>

<p>The original Kinesis Advantage 2 keyboard controller (KB600) uses USB 2.0, but
in Full Speed mode (<code>Spd=12</code>), i.e. no faster than USB 1.1. In addition, they
specify <code>bInterval=10</code>, which results in a 10ms polling interval (<code>Ivl=10ms</code>):</p>

<pre><code>T:  Bus=01 Lev=02 Prnt=09 Port=02 Cnt=02 Dev#= 52 Spd=12   MxCh= 0
D:  Ver= 2.00 Cls=00(&gt;ifc ) Sub=00 Prot=00 MxPS=64 #Cfgs=  1
P:  Vendor=29ea ProdID=0102 Rev= 1.00
S:  Manufacturer=Kinesis
S:  Product=Advantage2 Keyboard
C:* #Ifs= 3 Cfg#= 1 Atr=a0 MxPwr=100mA
I:* If#= 0 Alt= 0 #EPs= 1 Cls=03(HID  ) Sub=01 Prot=02 Driver=usbhid
E:  Ad=83(I) Atr=03(Int.) MxPS=   8 Ivl=10ms
I:* If#= 1 Alt= 0 #EPs= 1 Cls=03(HID  ) Sub=01 Prot=01 Driver=usbhid
E:  Ad=84(I) Atr=03(Int.) MxPS=   8 Ivl=2ms
I:* If#= 2 Alt= 0 #EPs= 1 Cls=03(HID  ) Sub=00 Prot=00 Driver=usbhid
E:  Ad=85(I) Atr=03(Int.) MxPS=   8 Ivl=2ms
</code></pre>

<p>My recommendation:</p>

<ul>
<li>With USB 1.1 Full Speed, definitely specify <code>bInterval=1</code>. I’m not aware of
any downsides.</li>
<li>With USB 2.0 High Speed, I also think <code>bInterval=1</code> is a good choice, but I am
less certain. If you run into trouble, reduce to <code>bInterval=3</code> and send me a
message :)</li>
</ul>

<p>For details on measuring, see <a href="#appendixb">Appendix B: USB polling interval (device
side)</a>.</p>

<p>Example change: <a href="https://github.com/qmk/qmk_firmware/pull/12625">https://github.com/qmk/qmk_firmware/pull/12625</a></p>

<h3 id="fastmatrixscan">Faster matrix scan</h3>

<p>The purpose of a keyboard controller is reporting pressed keys after scanning
the key matrix. The more scans a keyboard controller can do per second, the
faster it can react to your key press.</p>

<p>How many scans your controller does depends on multiple factors:</p>

<ul>
<li><p>The clock speed of your micro controller. It’s worth checking if your micro
controller model supports running at faster clock speeds, or upgrading your
keyboard to a faster model to begin with. There is a point of diminishing
returns, which I would guess is at ≈100 MHz. Comparing e.g. the kint36 at 120
MHz vs. 180 MHz, the difference in scan-to-scan is 5μs.</p></li>

<li><p>How much other code your firmware runs aside from matrix scanning. If you
enable any non-standard QMK features, or even self-written code, it’s worth
disabling and measuring.</p></li>

<li><p>Whether you run scans back-to-back or e.g. synchronized with USB
start-of-frame interrupts. QMK runs scans back-to-back, so this point is only
relevant for other firmwares.</p></li>

<li><p>How long you need to sleep to let the signal settle. Reducing your sleep times
results in more scans per second, but if you don’t sleep long enough, you’ll
see ghost key presses. See also the next section about Shorter sleeps.</p></li>
</ul>

<p>For details on measuring, see the <a href="#scantoscandelay">Scan-to-scan delay section</a>
above.</p>

<p>I also tried configuring the GPIOs to be faster to see if that would reduce the
required unselect delay, but unfortunately there was no difference between the
default setting and the fastest setting: drive strength 6 (<code>DSE=6</code>), fast
slew rate (<code>SRE=1</code>), 200 MHz (<code>SPEED=3</code>).</p>

<h3 id="shortsleeps">Shorter sleeps</h3>

<p>QMK calls <a href="https://www.chibios.org/dokuwiki/doku.php?id=chibios:documentation:books:rt:kernel_threading#delays_api">ChibiOS’s <code>chThdSleepMicroseconds</code>
function</a>
in its matrix scanning code. This function unfortunately has a rather long
shortest sleep duration of 1 ChibiOS tick: if you tell it to sleep less than
100μs, it will still sleep at least 100μs!</p>

<p>This is a problem on controllers such as the kint41, where we want to sleep for
only 10μs.</p>

<p>The length of a ChibiOS tick is determined by how the ARM SysTick timer is set
up on the specific micro controller you’re using. While the SysTick timer itself
could be configured to fire more frequently, it is not advisable to shorten
ChibiOS ticks: <code>chSysTimerHandlerI()</code> <a href="http://forum.chibios.org/viewtopic.php?t=3712#p27851">must be executable in less than one
tick</a>.</p>

<p>Instead, I found it easier to implement short delays by busy-looping until the
ARM Cycle Counter Register (<code>CYCCNT</code>) indicates enough time has passed. Here’s
an example from <code>keyboards/kinesis/kint41/kint41.c</code>:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#60a0b0;font-style:italic">// delay_inline sleeps for |cycles| (e.g. sleeping for F_CPU will sleep 1s).
</span><span style="color:#60a0b0;font-style:italic">//
</span><span style="color:#60a0b0;font-style:italic">// delay_inline assumes the cycle counter has already been initialized and
</span><span style="color:#60a0b0;font-style:italic">// should not be modified, i.e. is safe to call during keyboard matrix scan.
</span><span style="color:#60a0b0;font-style:italic">//
</span><span style="color:#60a0b0;font-style:italic">// ChibiOS enables the cycle counter in chcore_v7m.c.
</span><span style="color:#60a0b0;font-style:italic"></span><span style="color:#007020;font-weight:bold">static</span> <span style="color:#902000">void</span> <span style="color:#06287e">delay_inline</span>(<span style="color:#007020;font-weight:bold">const</span> uint32_t cycles) {
  <span style="color:#007020;font-weight:bold">const</span> uint32_t start <span style="color:#666">=</span> DWT<span style="color:#666">-&gt;</span>CYCCNT;
  <span style="color:#007020;font-weight:bold">while</span> ((DWT<span style="color:#666">-&gt;</span>CYCCNT <span style="color:#666">-</span> start) <span style="color:#666">&lt;</span> cycles) {
    <span style="color:#60a0b0;font-style:italic">// busy-loop until time has passed
</span><span style="color:#60a0b0;font-style:italic"></span>  }
}

<span style="color:#902000">void</span> <span style="color:#06287e">matrix_output_unselect_delay</span>(<span style="color:#902000">void</span>) {
  <span style="color:#60a0b0;font-style:italic">// 600 cycles at 0.6 cycles/ns == 1μs
</span><span style="color:#60a0b0;font-style:italic"></span>  <span style="color:#007020;font-weight:bold">const</span> uint32_t cycles_per_us <span style="color:#666">=</span> <span style="color:#40a070">600</span>;
  delay_inline(<span style="color:#40a070">10</span> <span style="color:#666">*</span> cycles_per_us);
}</code></pre></div>
<p>Of course, the cycles/ns value is specific to the frequency at which your micro
controller runs, so this code needs to be adjusted for each platform.</p>

<h2 id="results">Results</h2>

<p>With the QMK keyboard firmware configured for lowest input latency, how do the
different Kinesis keyboard controller compare? Here are my measurements:</p>

<table>
<thead>
<tr>
<th>model</th>
<th>CPU speed</th>
<th>USB poll interval</th>
<th>scan-to-scan</th>
<th>scan rate</th>
<th>caps-to-report</th>
</tr>
</thead>

<tbody>
<tr>
<td>kint41</td>
<td>600 MHz</td>
<td>125μs</td>
<td>181μs</td>
<td>5456 scans/s</td>
<td>930µs ±17%</td>
</tr>

<tr>
<td>kinX</td>
<td>120 MHz</td>
<td>125μs</td>
<td>213μs</td>
<td>4694 scans/s</td>
<td>953µs ±15%</td>
</tr>

<tr>
<td>kint36</td>
<td>180 MHz</td>
<td>1000μs</td>
<td>444μs</td>
<td>2252 scans/s</td>
<td>1.97ms ±15%</td>
</tr>

<tr>
<td>kint2pp</td>
<td>16 MHz</td>
<td>1000μs</td>
<td>926μs</td>
<td>1078 scans/s</td>
<td>3.27ms ±32%</td>
</tr>

<tr>
<td>original</td>
<td>60 MHz</td>
<td>10000μs</td>
<td>1936μs</td>
<td>516 scans/s</td>
<td>13.6ms ±21%</td>
</tr>
</tbody>
</table>

<p>The changes required to obtain these results are included since QMK 0.12.38
(2021-04-20).</p>

<p><a href="https://github.com/kinx-project/kint/issues/5">kint41 support is being added</a>
with all required changes to begin with, but still in progress.</p>

<p>The following sections go into detail about the results.</p>

<h3 id="kint41">kint41</h3>

<p>I am glad that the most recent Teensy 4.1 micro controller takes the lead! The
kinX controller achieved similar numbers, but was quite difficult to build, so
few people ended up using it.</p>

<p>The key improvement compared to the Teensy 3.6 is the now-available USB 2.0 High
Speed, and the powerful clock speed of 600 MHz allows for an even faster matrix
scan rate.</p>

<h3 id="kinx">kinX</h3>

<p>In my <a href="/posts/2018-04-17-kinx-keyboard-controller/">previous article about the kinX
controller</a>, I measured the kinX
scan delay as ≈100μs. During my work on this article, I learnt that the ≈100μs
figure was misleading: the measurement code turned off interrupts to measure
only the scan function. While that is technically correct, it is not a useful
measure, as in practice, <a href="https://github.com/kinx-project/mk66f-fw/commit/cae21f3d13331061bcd8c9d411adbb0d7d8c0ae4">interrupts should not be
disabled</a>,
and the scanning function is interrupted frequently enough that it comes in at
≈208μs.</p>

<p>I also fixed the USB polling interval in the kinX firmware, which <a href="https://github.com/kinx-project/mk66f-fw/commit/b40ae0287ed3b042886e29621dbeecefba1c148b">wasn’t set to
<code>bInterval=1</code></a>.</p>

<h3 id="original-kinesis">Original Kinesis</h3>

<p>The original keyboard controller that the Kinesis Advantage 2 (KB600) keyboard
comes with uses <a href="https://www.microchip.com/wwwproducts/en/AT32UC3B0256#datasheet-toggle">an AT32UC3B0256 micro
controller</a>
which is clocked at 60 MHz, but the measured input latency is much higher than
even the slowest kint controller (kint2pp at 16 MHz). What gives?</p>

<p>Here’s what we can deduce without access to their firmware:</p>

<ol>
<li>They seem to be using an <a href="#eagerdebounce">eager debounce algorithm</a> (good!),
otherwise we would observe even higher latency.</li>
<li>Their <a href="#quickusbpolling">USB polling interval</a> setting (<code>bInterval=10</code>) is
excessively high, even more so because they are using USB Full Speed with
longer USB frames. I would recommend they change it to <code>bInterval=1</code> for up
to 10ms less input latency!</li>
<li>The matrix scan rate is twice as slow as with my kint2pp. I can’t say for
sure why this is. Perhaps their firmware does a lot of other things between
matrix scans.</li>
</ol>

<p>Note that we could not apply the <a href="#eagercaps">Eager Caps Lock LED</a> firmware
change to the original controller, which is why the measurement variance is
±21%. This variance includes ± 1.9ms for finishing a matrix scan before updating
the LED state.</p>

<h2 id="conclusion">Conclusion</h2>

<p>After analyzing the different controllers in my measurement environment, I think
the following factors play the largest role in keyboard input latency, ordered
by importance:</p>

<ol>
<li>Does the firmware use an <a href="#eagerdebounce">eager debounce algorithm</a>?</li>
<li>Does the device specify a <a href="#quickusbpolling">quick USB polling rate (<code>bInterval</code>
setting)</a>?</li>
<li>Is the matrix scan frequency in the expected range, or are there unexpected
slow-downs?</li>
</ol>

<p>Hopefully, this article gives you all the tools you need to measure and reduce
keyboard input latency of your own keyboard controller!</p>

<h2 id="appendix-a-isitsnappy">Appendix A: isitsnappy</h2>

<p>The iPhone app <a href="https://isitsnappy.com/">Is It Snappy?</a> records video using the
iPhone’s 240 fps camera and allows you to mark the frame that starts
respectively ends the measurement.</p>

<p>The app does a good job of making this otherwise tedious process of navigating a
video frame by frame much more pleasant.</p>

<p>However, for measuring keyboard input latency, I think this approach is futile:</p>

<ul>
<li>The resolution is too imprecise. At 240 fps, that means each frame represents
4.6ms of time, which is already higher than the input latency of our slowest
micro controller.</li>
<li>Visually deciding whether a key switch is pressed or not pressed, at
frame-perfect precision, seems impossible to me.</li>
</ul>

<p>I believe the app can work, provided the latency you want to measure is really
high. But with the devices covered in this article, the app couldn’t measure
even 10ms of injected input latency.</p>

<h2 id="appendixb">Appendix B: USB polling interval (device side)</h2>

<p>You can also verify the USB polling interval on the device side. In the SOF
(Start Of Frame) interrupt in <code>tmk_core/protocol/chibios/usb_main.c</code>, we can
print the cycle delta to the previous SOF callback, every second:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#007020">#include</span> <span style="color:#007020">&#34;timer.h&#34;</span><span style="color:#007020">
</span><span style="color:#007020"></span>
<span style="color:#007020;font-weight:bold">static</span> uint32_t last_sof <span style="color:#666">=</span> <span style="color:#40a070">0</span>;
<span style="color:#007020;font-weight:bold">static</span> uint32_t sof_timer <span style="color:#666">=</span> <span style="color:#40a070">0</span>;
<span style="color:#902000">void</span> <span style="color:#06287e">kbd_sof_cb</span>(USBDriver <span style="color:#666">*</span>usbp) {
  (<span style="color:#902000">void</span>)usbp;

  uint32_t now <span style="color:#666">=</span> DWT<span style="color:#666">-&gt;</span>CYCCNT;
  uint32_t delta <span style="color:#666">=</span> now <span style="color:#666">-</span> last_sof;
  last_sof <span style="color:#666">=</span> now;

  uint32_t timer_now <span style="color:#666">=</span> timer_read32();
  <span style="color:#007020;font-weight:bold">if</span> (TIMER_DIFF_32(timer_now, sof_timer) <span style="color:#666">&gt;</span> <span style="color:#40a070">1000</span>) {
    sof_timer <span style="color:#666">=</span> timer_now;
    dprintf(<span style="color:#4070a0">&#34;sof delta: %u cycles&#34;</span>, delta);
  }
}</code></pre></div>
<p>Using <code>hid_listen</code>, we expect to see ≈75000 cycles of delta, which
corresponds to the 125μs microframe latency of USB 2.0 High Speed with
<code>bInterval=1</code> in the USB device descriptor:</p>

<p>125μs * 1000 * 0.6 cycles/ns = 75000 cycles</p>

</div>

      </div>
<div id="ms_toc">
  <div>
    <strong>Table Of Contents</strong>

    <nav class="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#measurement-setup">Measurement setup</a>
<ul>
<li><a href="#enable-the-debug-console-in-qmk">Enable the debug console in QMK</a></li>
<li><a href="#finding-the-pins">Finding the pins</a></li>
<li><a href="#eagercaps">Eager Caps Lock LED</a></li>
<li><a href="#host-side-linux">Host side (Linux)</a></li>
<li><a href="#code-to-simulate-key-presses-and-take-measurements">Code to simulate key presses and take measurements</a></li>
<li><a href="#running-measurements">Running measurements</a></li>
<li><a href="#scantoscandelay">Scan-to-scan delay</a></li>
</ul></li>
<li><a href="#measurement-harness">Measurement harness</a>
<ul>
<li><a href="#kint36-kint41-gpio">kint36, kint41: GPIO</a></li>
<li><a href="#kint2pp-5v">kint2pp: 5V</a></li>
<li><a href="#kinx-fpc">kinX: FPC</a></li>
<li><a href="#original-kinesis-controller">Original Kinesis controller</a></li>
</ul></li>
<li><a href="#qmk-input-latency">QMK input latency</a>
<ul>
<li><a href="#eagerdebounce">Eager debounce</a></li>
<li><a href="#quickusbpolling">Quicker USB polling interval</a></li>
<li><a href="#fastmatrixscan">Faster matrix scan</a></li>
<li><a href="#shortsleeps">Shorter sleeps</a></li>
</ul></li>
<li><a href="#results">Results</a>
<ul>
<li><a href="#kint41">kint41</a></li>
<li><a href="#kinx">kinX</a></li>
<li><a href="#original-kinesis">Original Kinesis</a></li>
</ul></li>
<li><a href="#conclusion">Conclusion</a></li>
<li><a href="#appendix-a-isitsnappy">Appendix A: isitsnappy</a></li>
<li><a href="#appendixb">Appendix B: USB polling interval (device side)</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    </main><div id="ms_footer">
  © 2020 Michael Stapelberg • all articles under <a href="https://creativecommons.org/licenses/by/4.0/">Creative Commons CC-BY license</a>
</div>
</body>
</html>
