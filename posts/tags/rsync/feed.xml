<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Michael Stapelbergs Website: posts tagged rsync</title>
  <link href="https://michael.stapelberg.ch/posts/tags/rsync/feed.xml" rel="self"/>
  <link href="https://michael.stapelberg.ch/posts/tags/rsync/"/>


  <id>https://michael.stapelberg.ch/posts/tags/rsync/</id>
  <generator>Hugo -- gohugo.io</generator>
  <entry>
    <title type="html"><![CDATA[Tips to debug hanging Go programs]]></title>
    <link href="https://michael.stapelberg.ch/posts/2025-02-27-debug-hanging-go-programs/"/>
    <id>https://michael.stapelberg.ch/posts/2025-02-27-debug-hanging-go-programs/</id>
    <published>2025-02-27T17:51:38+01:00</published>
    <content type="html"><![CDATA[<p>I was helping someone get my <a href="https://github.com/gokrazy/rsync">gokrazy/rsync</a>
implementation set up to synchronize <a href="https://en.wikipedia.org/wiki/Resource_Public_Key_Infrastructure">RPKI
data</a> (used
for securing BGP routing infrastructure), when we discovered that with the right
invocation, my rsync receiver would just hang indefinitely.</p>
<p>This was a quick problem to solve, but in the process, I realized that I should
probably write down a few Go debugging tips I have come to appreciate over the
years!</p>
<h2 id="scenario-hanging-go-program">Scenario: hanging Go program</h2>
<p>If you want to follow along, you can reproduce the issue by building an older
version of gokrazy/rsync, just before the bug fix commit (you’ll need <a href="https://go.dev/dl/">Go 1.22
or newer</a>):</p>
<pre tabindex="0"><code>git clone https://github.com/gokrazy/rsync
cd rsync
git reset --hard 6c89d4dda3be055f19684c0ed56d623da458194e^
go install ./cmd/...
</code></pre><p>Now we can try to sync the repository:</p>
<pre tabindex="0"><code>% gokr-rsync \
  -rtO \
  --delete \
  rsync://rsync.paas.rpki.ripe.net/repository/ \
  /tmp/rpki-repo
[…]
2025/02/08 09:35:10 Opening TCP connection to rsync.paas.rpki.ripe.net:873
2025/02/08 09:35:10 rsync module &#34;repo&#34;, path &#34;repo/&#34;
2025/02/08 09:35:10 (Client) Protocol versions: remote=31, negotiated=27
2025/02/08 09:35:10 Client checksum: md4
2025/02/08 09:35:10 sending daemon args: [--server --sender -tr . repo/]
2025/02/08 09:35:10 exclusion list sent
2025/02/08 09:35:10 receiving file list
2025/02/08 09:35:11 [Receiver] i=0 ? . mode=40755 len=4096 uid=0 gid=0 flags=?
[…]
2025/02/08 09:35:11 [Receiver] i=89 ? clonoth/1/3139332e33322e3130302e302f32342d3234203d3e203537313936.roa mode=100644 len=1747 uid=0 gid=0 flags=?
</code></pre><p>…and then the program just sits there.</p>
<h2 id="sigquit-stack-trace">Tip 1: Press Ctrl+\ (SIGQUIT) to print a stack trace</h2>
<p>The easiest way to look at where a Go program is hanging is to press <code>Ctrl+\</code>
(backslash) to <a href="https://en.wikipedia.org/wiki/Signal_(IPC)#SIGQUIT">make the terminal send it a <code>SIGQUIT</code>
signal</a>. When the Go runtime
receives <code>SIGQUIT</code>, it prints a stack trace to the terminal before exiting the
process. This behavior is enabled by default and can be customized via the
<code>GOTRACEBACK</code> environment variable, see the <a href="https://pkg.go.dev/runtime"><code>runtime</code> package
docs</a>.</p>
<p>Here is what the output looks like in our case. I have made the font small so
that you can recognize the shape of the output (the details are not important,
continue reading below):</p>
<div style="font-size: 60%">
<pre tabindex="0"><code>^\SIGQUIT: quit
PC=0x47664e m=0 sigcode=128

goroutine 0 gp=0x6e6020 m=0 mp=0x6e6ec0 [idle]:
internal/runtime/syscall.Syscall6()
	/home/michael/sdk/go1.23.0/src/internal/runtime/syscall/asm_linux_amd64.s:36 +0xe fp=0x7ffc58665090 sp=0x7ffc58665088 pc=0x47664e
internal/runtime/syscall.EpollWait(0x586651e0?, {0x7ffc5866511c?, 0x3000000018?, 0x7ffc586651f0?}, 0x58665110?, 0x7ffc?)
	/home/michael/sdk/go1.23.0/src/internal/runtime/syscall/syscall_linux.go:32 +0x45 fp=0x7ffc586650e0 sp=0x7ffc58665090 pc=0x4765e5
runtime.netpoll(0xc0000000c0?)
	/home/michael/sdk/go1.23.0/src/runtime/netpoll_epoll.go:116 +0xd2 fp=0x7ffc58665768 sp=0x7ffc586650e0 pc=0x432332
runtime.findRunnable()
	/home/michael/sdk/go1.23.0/src/runtime/proc.go:3580 +0x8c5 fp=0x7ffc586658e0 sp=0x7ffc58665768 pc=0x43f045
runtime.schedule()
	/home/michael/sdk/go1.23.0/src/runtime/proc.go:3995 +0xb1 fp=0x7ffc58665918 sp=0x7ffc586658e0 pc=0x4405b1
runtime.park_m(0xc0000061c0)
	/home/michael/sdk/go1.23.0/src/runtime/proc.go:4102 +0x1eb fp=0x7ffc58665970 sp=0x7ffc58665918 pc=0x4409cb
runtime.mcall()
	/home/michael/sdk/go1.23.0/src/runtime/asm_amd64.s:459 +0x4e fp=0x7ffc58665988 sp=0x7ffc58665970 pc=0x470e2e

goroutine 1 gp=0xc0000061c0 m=nil [IO wait]:
runtime.gopark(0x452658?, 0x0?, 0x98?, 0xb3?, 0xb?)
	/home/michael/sdk/go1.23.0/src/runtime/proc.go:424 +0xce fp=0xc0000eb358 sp=0xc0000eb338 pc=0x46bc0e
runtime.netpollblock(0x4a01b8?, 0x4058e6?, 0x0?)
	/home/michael/sdk/go1.23.0/src/runtime/netpoll.go:575 +0xf7 fp=0xc0000eb390 sp=0xc0000eb358 pc=0x4318f7
internal/poll.runtime_pollWait(0x7ef586628808, 0x72)
	/home/michael/sdk/go1.23.0/src/runtime/netpoll.go:351 +0x85 fp=0xc0000eb3b0 sp=0xc0000eb390 pc=0x46af05
internal/poll.(*pollDesc).wait(0xc0000ce180?, 0xc00020e99c?, 0x0)
	/home/michael/sdk/go1.23.0/src/internal/poll/fd_poll_runtime.go:84 +0x27 fp=0xc0000eb3d8 sp=0xc0000eb3b0 pc=0x4b0ce7
internal/poll.(*pollDesc).waitRead(...)
	/home/michael/sdk/go1.23.0/src/internal/poll/fd_poll_runtime.go:89
internal/poll.(*FD).Read(0xc0000ce180, {0xc00020e99c, 0x4, 0x4})
	/home/michael/sdk/go1.23.0/src/internal/poll/fd_unix.go:165 +0x27a fp=0xc0000eb470 sp=0xc0000eb3d8 pc=0x4b17da
net.(*netFD).Read(0xc0000ce180, {0xc00020e99c?, 0x6eeea0?, 0x1?})
	/home/michael/sdk/go1.23.0/src/net/fd_posix.go:55 +0x25 fp=0xc0000eb4b8 sp=0xc0000eb470 pc=0x4f7e85
net.(*conn).Read(0xc000206000, {0xc00020e99c?, 0xc000212000?, 0x6e6ec0?})
	/home/michael/sdk/go1.23.0/src/net/net.go:189 +0x45 fp=0xc0000eb500 sp=0xc0000eb4b8 pc=0x5001a5
net.(*TCPConn).Read(0x0?, {0xc00020e99c?, 0xc0000eb568?, 0x46d449?})
	&lt;autogenerated&gt;:1 +0x25 fp=0xc0000eb530 sp=0xc0000eb500 pc=0x50bb25
io.ReadAtLeast({0x5d9640, 0xc000206000}, {0xc00020e99c, 0x4, 0x4}, 0x4)
	/home/michael/sdk/go1.23.0/src/io/io.go:335 +0x90 fp=0xc0000eb578 sp=0xc0000eb530 pc=0x4957d0
io.ReadFull(...)
	/home/michael/sdk/go1.23.0/src/io/io.go:354
encoding/binary.Read({0x5d9640, 0xc000206000}, {0x5da8b0, 0x7059a0}, {0x55e7c0, 0xc0000eb6a0})
	/home/michael/sdk/go1.23.0/src/encoding/binary/binary.go:244 +0xa5 fp=0xc0000eb670 sp=0xc0000eb578 pc=0x5102a5
github.com/gokrazy/rsync/internal/rsyncwire.(*MultiplexReader).ReadMsg(0xc00020a100)
	/home/michael/kr/rsync/internal/rsyncwire/wire.go:50 +0x48 fp=0xc0000eb6e8 sp=0xc0000eb670 pc=0x514428
github.com/gokrazy/rsync/internal/rsyncwire.(*MultiplexReader).Read(0x7ef5869b9a68?, {0xc000280000, 0x40000, 0x4dd4fb?})
	/home/michael/kr/rsync/internal/rsyncwire/wire.go:72 +0x2f fp=0xc0000eb788 sp=0xc0000eb6e8 pc=0x5145af
bufio.(*Reader).Read(0xc0002020c0, {0xc00020e998, 0x4, 0x40ece5?})
	/home/michael/sdk/go1.23.0/src/bufio/bufio.go:241 +0x197 fp=0xc0000eb7c0 sp=0xc0000eb788 pc=0x4d5a57
io.ReadAtLeast({0x5d93e0, 0xc0002020c0}, {0xc00020e998, 0x4, 0x4}, 0x4)
	/home/michael/sdk/go1.23.0/src/io/io.go:335 +0x90 fp=0xc0000eb808 sp=0xc0000eb7c0 pc=0x4957d0
io.ReadFull(...)
	/home/michael/sdk/go1.23.0/src/io/io.go:354
github.com/gokrazy/rsync/internal/rsyncwire.(*Conn).ReadInt32(0xc000208060)
	/home/michael/kr/rsync/internal/rsyncwire/wire.go:163 +0x4a fp=0xc0000eb850 sp=0xc0000eb808 pc=0x51490a
github.com/gokrazy/rsync/internal/receiver.(*Transfer).recvIdMapping1(0xc000202120, 0x5a9b58)
	/home/michael/kr/rsync/internal/receiver/uidlist.go:16 +0x3d fp=0xc0000eb8c0 sp=0xc0000eb850 pc=0x51fc7d
github.com/gokrazy/rsync/internal/receiver.(*Transfer).RecvIdList(0xc000202120)
	/home/michael/kr/rsync/internal/receiver/uidlist.go:52 +0x1dd fp=0xc0000eba08 sp=0xc0000eb8c0 pc=0x51ffbd
github.com/gokrazy/rsync/internal/receiver.(*Transfer).ReceiveFileList(0xc000202120)
	/home/michael/kr/rsync/internal/receiver/flist.go:229 +0x378 fp=0xc0000ebb10 sp=0xc0000eba08 pc=0x51c5b8
github.com/gokrazy/rsync/internal/receivermaincmd.clientRun({{0x5d9280, 0xc000078058}, {0x5d92a0, 0xc000078060}, {0x5d92a0, 0xc000078068}}, 0xc0000d0d90, {0x7ef53d47efc8, 0xc000206000}, {0x7ffc5866600e, ...}, ...)
	/home/michael/kr/rsync/internal/receivermaincmd/receivermaincmd.go:341 +0x5cd fp=0xc0000ebc10 sp=0xc0000ebb10 pc=0x550c2d
github.com/gokrazy/rsync/internal/receivermaincmd.socketClient({{0x5d9280, 0xc000078058}, {0x5d92a0, 0xc000078060}, {0x5d92a0, 0xc000078068}}, 0xc0000d0d90, {0x7ffc58665ff4?, 0x1?}, {0x7ffc5866600e, ...})
	/home/michael/kr/rsync/internal/receivermaincmd/clientserver.go:44 +0x425 fp=0xc0000ebcd0 sp=0xc0000ebc10 pc=0x54c205
github.com/gokrazy/rsync/internal/receivermaincmd.rsyncMain({{0x5d9280, 0xc000078058}, {0x5d92a0, 0xc000078060}, {0x5d92a0, 0xc000078068}}, 0xc0000d0d90, {0xc00007e440, 0x1, 0x2}, ...)
	/home/michael/kr/rsync/internal/receivermaincmd/receivermaincmd.go:160 +0x5d7 fp=0xc0000ebdf0 sp=0xc0000ebcd0 pc=0x54f697
github.com/gokrazy/rsync/internal/receivermaincmd.Main({0xc0000160a0, 0x5, 0x5}, {0x5d9280?, 0xc000078058?}, {0x5d92a0?, 0xc000078060?}, {0x5d92a0?, 0xc000078068?})
	/home/michael/kr/rsync/internal/receivermaincmd/receivermaincmd.go:394 +0x272 fp=0xc0000ebee8 sp=0xc0000ebdf0 pc=0x5510d2
main.main()
	/home/michael/kr/rsync/cmd/gokr-rsync/rsync.go:12 +0x4e fp=0xc0000ebf50 sp=0xc0000ebee8 pc=0x5515ae
runtime.main()
	/home/michael/sdk/go1.23.0/src/runtime/proc.go:272 +0x28b fp=0xc0000ebfe0 sp=0xc0000ebf50 pc=0x438d4b
runtime.goexit({})
	/home/michael/sdk/go1.23.0/src/runtime/asm_amd64.s:1700 +0x1 fp=0xc0000ebfe8 sp=0xc0000ebfe0 pc=0x472e61

goroutine 2 gp=0xc000006c40 m=nil [force gc (idle)]:
runtime.gopark(0x0?, 0x0?, 0x0?, 0x0?, 0x0?)
	/home/michael/sdk/go1.23.0/src/runtime/proc.go:424 +0xce fp=0xc000074fa8 sp=0xc000074f88 pc=0x46bc0e
runtime.goparkunlock(...)
	/home/michael/sdk/go1.23.0/src/runtime/proc.go:430
runtime.forcegchelper()
	/home/michael/sdk/go1.23.0/src/runtime/proc.go:337 +0xb3 fp=0xc000074fe0 sp=0xc000074fa8 pc=0x439093
runtime.goexit({})
	/home/michael/sdk/go1.23.0/src/runtime/asm_amd64.s:1700 +0x1 fp=0xc000074fe8 sp=0xc000074fe0 pc=0x472e61
created by runtime.init.7 in goroutine 1
	/home/michael/sdk/go1.23.0/src/runtime/proc.go:325 +0x1a
</code></pre></div>
<p>Phew! This output is pretty dense.</p>
<p>We can use the <a href="https://github.com/maruel/panicparse">https://github.com/maruel/panicparse</a> program to present this
stack trace in a more colorful and much shorter version:</p>















<a href="https://michael.stapelberg.ch/posts/2025-02-27-debug-hanging-go-programs/2025-02-08-panicparse.jpg"><img
  srcset="https://michael.stapelberg.ch/posts/2025-02-27-debug-hanging-go-programs/2025-02-08-panicparse_hu3e0f2d5aa6180df20bb553ed5c6fa57b_1741005_1200x0_resize_q75_box.jpg 2x,https://michael.stapelberg.ch/posts/2025-02-27-debug-hanging-go-programs/2025-02-08-panicparse_hu3e0f2d5aa6180df20bb553ed5c6fa57b_1741005_1800x0_resize_q75_box.jpg 3x"
  src="https://michael.stapelberg.ch/posts/2025-02-27-debug-hanging-go-programs/2025-02-08-panicparse_hu3e0f2d5aa6180df20bb553ed5c6fa57b_1741005_600x0_resize_q75_box.jpg"
  
  width="600"
  height="394"
  style="

border: 1px solid #000;

"
  
  loading="lazy"></a>



<p>The functions helpfully highlighted in red are where the problem lies: My rsync
receiver implementation was incorrectly expecting the server to send a uid/gid
list, despite the PreserveUid and PreserveGid options not being enabled. <a href="https://github.com/gokrazy/rsync/commit/6c89d4dda3be055f19684c0ed56d623da458194e">Commit
<code>6c89d4d</code></a>
fixes the issue.</p>
<h2 id="attach-dlv">Tip 2: Attach the delve debugger to the process</h2>
<p>If dumping the stack trace in the moment is not sufficient to diagnose the
problem, you can go one step further and reach for an interactive debugger.</p>
<p>The most well-known Linux debugger is probably GDB, but when working with Go, I
recommend using <a href="https://github.com/go-delve/delve">the delve debugger</a> instead
as it typically works better. Install delve if you haven’t already:</p>
<pre tabindex="0"><code>% go install github.com/go-delve/delve/cmd/dlv@latest
</code></pre><p>In this article, I am using delve v1.24.0.</p>
<aside class="admonition note">
  <div class="note-container">
    <div class="note-icon" style="width: 20px; height: 20px">
      <svg id="exclamation-icon" width="100%" height="100%" viewBox="0 0 24 24" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:1.41421;">
    <path d="M0,0L24,0L24,24L0,24L0,0Z" style="fill:none;"/>
    <g transform="matrix(1.2,0,0,1.2,-2.4,-2.4)">
        <path d="M12,2C6.48,2 2,6.48 2,12C2,17.52 6.48,22 12,22C17.52,22 22,17.52 22,12C22,6.48 17.52,2 12,2ZM13,17L11,17L11,15L13,15L13,17ZM13,13L11,13L11,7L13,7L13,13Z" style="fill-rule:nonzero;"/>
    </g>
</svg>

    </div>
    <div class="admonition-content"><p><strong>Note:</strong> If you want to explore local variables, you should rebuild your
program without optimizations and inlining (see the <a href="https://github.com/go-delve/delve/blob/master/Documentation/usage/dlv_exec.md"><code>dlv exec</code>
docs</a>):</p>
<pre tabindex="0"><code>% go install -gcflags=all=&#34;-N -l&#34; ./cmd/...
</code></pre></div>
  </div>
</aside>

<p>While you can run a new child process in a debugger (use <code>dlv exec</code>) without any
special permissions, attaching existing processes in a debugger is <a href="https://www.kernel.org/doc/Documentation/security/Yama.txt">disabled by
default in Linux</a>
for security reasons. We can allow this feature (remember to turn it off later!)
using:</p>
<pre tabindex="0"><code>% sudo sysctl -w kernel.yama.ptrace_scope=0
kernel.yama.ptrace_scope = 0
</code></pre><p>…and then we can just <code>dlv attach</code> to the hanging <code>gokr-rsync</code> process:</p>
<pre tabindex="0"><code>% dlv attach $(pidof gokr-rsync)
Type &#39;help&#39; for list of commands.
(dlv)
</code></pre><p>Great. But if we just print a stack trace, we only see functions from the
<code>runtime</code> package:</p>
<pre tabindex="0"><code>(dlv) bt
0  0x000000000047bb83 in runtime.futex
   at /home/michael/sdk/go1.23.6/src/runtime/sys_linux_amd64.s:558
1  0x00000000004374d0 in runtime.futexsleep
   at /home/michael/sdk/go1.23.6/src/runtime/os_linux.go:69
2  0x000000000040d89d in runtime.notesleep
   at /home/michael/sdk/go1.23.6/src/runtime/lock_futex.go:170
3  0x000000000044123e in runtime.mPark
   at /home/michael/sdk/go1.23.6/src/runtime/proc.go:1866
4  0x000000000044290d in runtime.stopm
   at /home/michael/sdk/go1.23.6/src/runtime/proc.go:2886
5  0x00000000004433d0 in runtime.findRunnable
   at /home/michael/sdk/go1.23.6/src/runtime/proc.go:3623
6  0x0000000000444e1d in runtime.schedule
   at /home/michael/sdk/go1.23.6/src/runtime/proc.go:3996
7  0x00000000004451cb in runtime.park_m
   at /home/michael/sdk/go1.23.6/src/runtime/proc.go:4103
8  0x0000000000477eee in runtime.mcall
   at /home/michael/sdk/go1.23.6/src/runtime/asm_amd64.s:459
</code></pre><p>The reason is that no goroutine is running (the program is waiting indefinitely
to receive data from the server), so we see one of the OS threads waiting in the
Go scheduler.</p>
<p>We first need to switch to the goroutine we are interested in (<code>grs</code> prints all
goroutines), and then the stack trace looks like what we expect:</p>
<pre tabindex="0"><code>(dlv) gr 1
Switched from 0 to 1 (thread 414327)
(dlv) bt
 0  0x0000000000474ebc in runtime.gopark
    at /home/michael/sdk/go1.23.6/src/runtime/proc.go:425
 1  0x000000000043819e in runtime.netpollblock
    at /home/michael/sdk/go1.23.6/src/runtime/netpoll.go:575
 2  0x000000000047435c in internal/poll.runtime_pollWait
    at /home/michael/sdk/go1.23.6/src/runtime/netpoll.go:351
 3  0x00000000004ed15a in internal/poll.(*pollDesc).wait
    at /home/michael/sdk/go1.23.6/src/internal/poll/fd_poll_runtime.go:84
 4  0x00000000004ed1f1 in internal/poll.(*pollDesc).waitRead
    at /home/michael/sdk/go1.23.6/src/internal/poll/fd_poll_runtime.go:89
 5  0x00000000004ee351 in internal/poll.(*FD).Read
    at /home/michael/sdk/go1.23.6/src/internal/poll/fd_unix.go:165
 6  0x0000000000569bb3 in net.(*netFD).Read
    at /home/michael/sdk/go1.23.6/src/net/fd_posix.go:55
 7  0x000000000057a025 in net.(*conn).Read
    at /home/michael/sdk/go1.23.6/src/net/net.go:189
 8  0x000000000058fcc5 in net.(*TCPConn).Read
    at &lt;autogenerated&gt;:1
 9  0x00000000004b72e8 in io.ReadAtLeast
    at /home/michael/sdk/go1.23.6/src/io/io.go:335
10  0x00000000004b74d3 in io.ReadFull
    at /home/michael/sdk/go1.23.6/src/io/io.go:354
11  0x0000000000598d5f in encoding/binary.Read
    at /home/michael/sdk/go1.23.6/src/encoding/binary/binary.go:244
12  0x00000000005a0b7a in github.com/gokrazy/rsync/internal/rsyncwire.(*MultiplexReader).ReadMsg
    at /home/michael/kr/rsync/internal/rsyncwire/wire.go:50
13  0x00000000005a0f17 in github.com/gokrazy/rsync/internal/rsyncwire.(*MultiplexReader).Read
    at /home/michael/kr/rsync/internal/rsyncwire/wire.go:72
14  0x0000000000528de8 in bufio.(*Reader).Read
    at /home/michael/sdk/go1.23.6/src/bufio/bufio.go:241
15  0x00000000004b72e8 in io.ReadAtLeast
    at /home/michael/sdk/go1.23.6/src/io/io.go:335
16  0x00000000004b74d3 in io.ReadFull
    at /home/michael/sdk/go1.23.6/src/io/io.go:354
17  0x00000000005a19ef in github.com/gokrazy/rsync/internal/rsyncwire.(*Conn).ReadInt32
    at /home/michael/kr/rsync/internal/rsyncwire/wire.go:163
18  0x00000000005b77d2 in github.com/gokrazy/rsync/internal/receiver.(*Transfer).recvIdMapping1
    at /home/michael/kr/rsync/internal/receiver/uidlist.go:16
19  0x00000000005b7ea8 in github.com/gokrazy/rsync/internal/receiver.(*Transfer).RecvIdList
    at /home/michael/kr/rsync/internal/receiver/uidlist.go:52
20  0x00000000005b18db in github.com/gokrazy/rsync/internal/receiver.(*Transfer).ReceiveFileList
    at /home/michael/kr/rsync/internal/receiver/flist.go:229
21  0x0000000000605390 in github.com/gokrazy/rsync/internal/receivermaincmd.clientRun
    at /home/michael/kr/rsync/internal/receivermaincmd/receivermaincmd.go:341
22  0x00000000005fe572 in github.com/gokrazy/rsync/internal/receivermaincmd.socketClient
    at /home/michael/kr/rsync/internal/receivermaincmd/clientserver.go:44
23  0x0000000000602f10 in github.com/gokrazy/rsync/internal/receivermaincmd.rsyncMain
    at /home/michael/kr/rsync/internal/receivermaincmd/receivermaincmd.go:160
24  0x0000000000605e7e in github.com/gokrazy/rsync/internal/receivermaincmd.Main
    at /home/michael/kr/rsync/internal/receivermaincmd/receivermaincmd.go:394
25  0x0000000000606653 in main.main
    at /home/michael/kr/rsync/cmd/gokr-rsync/rsync.go:12
26  0x000000000043fa47 in runtime.main
    at /home/michael/sdk/go1.23.6/src/runtime/proc.go:272
27  0x000000000047bd01 in runtime.goexit
    at /home/michael/sdk/go1.23.6/src/runtime/asm_amd64.s:1700
</code></pre><h2 id="save-core-dump">Tip 3: Save a core dump for later</h2>
<p>If you don’t have time to poke around in the debugger now, you can save a core
dump for later.</p>
<aside class="admonition note">
  <div class="note-container">
    <div class="note-icon" style="width: 20px; height: 20px">
      <svg id="exclamation-icon" width="100%" height="100%" viewBox="0 0 24 24" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:1.41421;">
    <path d="M0,0L24,0L24,24L0,24L0,0Z" style="fill:none;"/>
    <g transform="matrix(1.2,0,0,1.2,-2.4,-2.4)">
        <path d="M12,2C6.48,2 2,6.48 2,12C2,17.52 6.48,22 12,22C17.52,22 22,17.52 22,12C22,6.48 17.52,2 12,2ZM13,17L11,17L11,15L13,15L13,17ZM13,13L11,13L11,7L13,7L13,13Z" style="fill-rule:nonzero;"/>
    </g>
</svg>

    </div>
    <div class="admonition-content"><strong>Tip:</strong> Check out my <a href="/posts/2024-10-22-debug-go-core-dumps-delve-export-bytes/">debugging Go core dumps with
delve</a> blog post from
2024 for more details! This section just explains how to collect core dumps.</div>
  </div>
</aside>

<p>In addition to printing the stack trace on <code>SIGQUIT</code>, we can make the Go runtime
crash the program, which in turn makes the Linux kernel write a core dump, by
running our program with the environment variable
<a href="https://pkg.go.dev/runtime"><code>GOTRACEBACK=crash</code></a>.</p>
<p>Modern Linux systems typically include <a href="https://manpages.debian.org/systemd-coredump.8"><code>systemd-coredump(8)</code></a>
 (but you might need to explicitly install it, for example on
Ubuntu) to collect core dumps (and remove old ones). You can use <a href="https://manpages.debian.org/coredumpctl.1"><code>coredumpctl(1)</code></a>
 to list and work with them. On macOS,
<a href="https://developer.apple.com/forums/thread/694233#695943022">collecting cores is more
involved</a>. I don’t
know about Windows.</p>
<p>In case your Linux system does not use <code>systemd-coredump</code>, you can use <code>ulimit -c unlimited</code> and set the kernel’s <code>kernel.core_pattern</code> sysctl setting. You can
find more details and options in the <a href="https://go.dev/wiki/CoreDumpDebugging">CoreDumpDebugging page of the Go
wiki</a>. For this article, we will stick to
<code>coredumpctl</code>:</p>
<pre tabindex="0"><code>% GOTRACEBACK=crash gokr-rsync -rtO --delete rsync://rsync.paas.rpki.ripe.net/repo/ /tmp/rpki-repo
[…]
^\SIGQUIT: quit
[…]
zsh: IOT instruction (core dumped)  GOTRACEBACK=crash gokr-rsync -rtO […]
</code></pre><p>The last line is what we want to see: it should say “core dumped”.</p>
<p>This core should now show up in <a href="https://manpages.debian.org/coredumpctl.1"><code>coredumpctl(1)</code></a>
:</p>
<pre tabindex="0"><code>% coredumpctl info
           PID: 414607 (gokr-rsync)
           UID: 1000 (michael)
           GID: 1000 (michael)
        Signal: 6 (ABRT)
     Timestamp: Sat 2025-02-08 10:18:27 CET (12s ago)
  Command Line: gokr-rsync -rtO --delete rsync://rsync.paas.rpki.ripe.net/repo/ /tmp/rpki-repo
    Executable: /bin/gokr-rsync
 Control Group: /user.slice/user-1000.slice/session-1.scope
          Unit: session-1.scope
         Slice: user-1000.slice
       Session: 1
     Owner UID: 1000 (michael)
       Boot ID: 6158dd3b52af4b8384c103a8a336fc02
    Machine ID: ecb5a44f1a5846ad871566e113bf8937
      Hostname: midna
       Storage: /var/lib/systemd/coredump/core.gokr-rsync.1000.6158dd3b52af4b8384c103a8a336fc02.414607.1739006307000000.zst (present)
  Size on Disk: 158.3K
       Message: Process 414607 (gokr-rsync) of user 1000 dumped core.
                
    Module [dso] without build-id.
    Module [dso]
    Stack trace of thread 1604447:
    #0  0x0000000000475a41 runtime.raise.abi0 (/bin/gokr-rsync + 0x75a41)
    #1  0x0000000000451d85 runtime.dieFromSignal (/bin/gokr-rsync + 0x51d85)
    #2  0x00000000004522e6 runtime.sigfwdgo (/bin/gokr-rsync + 0x522e6)
    #3  0x0000000000450c45 runtime.sigtrampgo (/bin/gokr-rsync + 0x50c45)
    #4  0x0000000000475d26 runtime.sigtramp.abi0 (/bin/gokr-rsync + 0x75d26)
    #5  0x0000000000475e20 n/a (/bin/gokr-rsync + 0x75e20)
    ELF object binary architecture: AMD x86-64
</code></pre><p>If you see only hexadecimal addresses followed by <code>n/a (n/a + 0x0)</code>, that means
<code>systemd-coredump</code> could not symbolize (= resolve addresses to function names)
your core dump. Here are a few possible reasons for missing symbolization:</p>
<ul>
<li>Linux 6.12 <a href="https://sourceware.org/bugzilla/show_bug.cgi?id=32713">started producing core dumps that elfutils cannot
symbolize</a>. <code>systemd-coredump</code>
uses elfutils for symbolization, so until this issue is fixed in either Linux
and/or elfutils, you’ll need to stick to Linux &lt;6.12 or revert <a href="https://github.com/torvalds/linux/commit/7d442a33bfe817ab2a735f3d2e430e36305354ea">the triggering
commit</a>.</li>
<li>With systemd v234-v256, <code>systemd-coredump</code> did not have permission to look
into programs living in the <code>/home</code> directory (fixed with <a href="https://github.com/systemd/systemd/commit/4ac1755be2d6c141fae7e57c42936e507c5b54e3">commit
<code>4ac1755</code></a>
in systemd v257+).
<ul>
<li>Similarly, <code>systemd-coredump</code> runs with
<a href="http://manpages.debian.org/systemd.exec"><code>PrivateTmp=yes</code></a>, meaning it
won’t be able to access programs you place in <code>/tmp</code>.</li>
</ul>
</li>
<li>Go builds with debug symbols by default, but maybe you are explicitly
stripping debug symbols in your build, by building with <code>-ldflags=-w</code>?</li>
</ul>
<p>We can now use <a href="https://manpages.debian.org/coredumpctl.1"><code>coredumpctl(1)</code></a>
 to launch delve for
this program + core dump:</p>
<pre tabindex="0"><code>% coredumpctl debug --debugger=dlv --debugger-arguments=core
[…]
Type &#39;help&#39; for list of commands.
(dlv) gr 1
Switched from 0 to 1 (thread 414607)
(dlv) bt
[…]
16  0x00000000004b74d3 in io.ReadFull
    at /home/michael/sdk/go1.23.6/src/io/io.go:354
17  0x00000000005a19ef in github.com/gokrazy/rsync/internal/rsyncwire.(*Conn).ReadInt32
    at /home/michael/kr/rsync/internal/rsyncwire/wire.go:163
18  0x00000000005b77d2 in github.com/gokrazy/rsync/internal/receiver.(*Transfer).recvIdMapping1
    at /home/michael/kr/rsync/internal/receiver/uidlist.go:16
19  0x00000000005b7ea8 in github.com/gokrazy/rsync/internal/receiver.(*Transfer).RecvIdList
    at /home/michael/kr/rsync/internal/receiver/uidlist.go:52
20  0x00000000005b18db in github.com/gokrazy/rsync/internal/receiver.(*Transfer).ReceiveFileList
    at /home/michael/kr/rsync/internal/receiver/flist.go:229
21  0x0000000000605390 in github.com/gokrazy/rsync/internal/receivermaincmd.clientRun
    at /home/michael/kr/rsync/internal/receivermaincmd/receivermaincmd.go:341
22  0x00000000005fe572 in github.com/gokrazy/rsync/internal/receivermaincmd.socketClient
    at /home/michael/kr/rsync/internal/receivermaincmd/clientserver.go:44
23  0x0000000000602f10 in github.com/gokrazy/rsync/internal/receivermaincmd.rsyncMain
    at /home/michael/kr/rsync/internal/receivermaincmd/receivermaincmd.go:160
24  0x0000000000605e7e in github.com/gokrazy/rsync/internal/receivermaincmd.Main
    at /home/michael/kr/rsync/internal/receivermaincmd/receivermaincmd.go:394
25  0x0000000000606653 in main.main
    at /home/michael/kr/rsync/cmd/gokr-rsync/rsync.go:12
26  0x000000000043fa47 in runtime.main
    at /home/michael/sdk/go1.23.6/src/runtime/proc.go:272
27  0x000000000047bd01 in runtime.goexit
    at /home/michael/sdk/go1.23.6/src/runtime/asm_amd64.s:1700
</code></pre><h2 id="conclusion">Conclusion</h2>
<p>In my experience, in the medium to long term, it always pays off to set up your
environment such that you can debug your programs conveniently. I strongly
encourage every programmer (and even users!) to invest time into your
development and debugging setup.</p>
<p>Luckily, Go comes with stack printing functionality by default (just press
<code>Ctrl+\</code>) and we can easily get a core dump out of our Go programs by running
them with <code>GOTRACEBACK=crash</code> — provided the system is set up to collect core
dumps.</p>
<p>Together with the delve debugger, this gives us all we need to effectively and
efficiently diagnose problems in Go programs.</p>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[rsync, article 3: How does rsync work?]]></title>
    <link href="https://michael.stapelberg.ch/posts/2022-07-02-rsync-how-does-it-work/"/>
    <id>https://michael.stapelberg.ch/posts/2022-07-02-rsync-how-does-it-work/</id>
    <published>2022-07-02T14:30:10+02:00</published>
    <content type="html"><![CDATA[<p>This post is the third article in a series of blog posts about rsync, <a href="../2022-06-18-rsync-overview/">see the
Series Overview</a>.</p>
<p>With rsync up and running, it’s time to take a peek under the hood of rsync to
better understand how it works.</p>
<h2 id="howdoesrsyncwork">How does rsync work?</h2>
<p>When talking about the rsync protocol, we need to distinguish between:</p>
<ul>
<li>protocol-level roles: “sender” and “receiver”</li>
<li>TCP roles: “client” and “server”</li>
</ul>
<p>All roles can be mixed and matched: both rsync clients (or servers!) can
either send or receive.</p>
<p>Now that you know the terminology, let’s take a high-level look at the rsync
protocol. We’ll look at protocol version 27, which is older but simpler, and
which is the most widely supported protocol version, implemented by <code>openrsync</code>
and other third-party implementations:</p>
<p><img src="2022-05-29-rsync-logical-view.svg" alt="rsync architecture"></p>
<p>The rsync protocol can be divided into two phases:</p>
<ol>
<li>
<p>In the first phase, the sender walks the local file tree to generate and send
the <em>file list</em> to the receiver. The file list must be transferred in full,
because both sides sort it by filename (later rsync protocol versions
eliminate this synchronous sorting step).</p>
</li>
<li>
<p>In the second phase, concurrently:</p>
<ul>
<li>The receiver compares and requests each file in the file list. The
receiver requests the full file when it didn’t exist on disk yet, or it
will send checksums for the rsync <em>hash search</em> algorithm when the file
already existed.</li>
<li>The receiver receives file data from the sender. The sender answers the
requests with just enough data to reconstruct the current file contents
based on what’s already on the receiver.</li>
</ul>
</li>
</ol>
<p>The architecture makes it easy to implement the second phase in 3 separate
processes, each of which sending to the network as fast as possible using heavy
pipelining. This results in utilizing the available hardware resources (I/O,
CPU, network) on sender and receiver to the fullest.</p>
<h3 id="observing-rsyncs-transfer-phases">Observing rsync’s transfer phases</h3>
<p>When starting an rsync transfer, looking at the resource usage of both
machines allows us to confirm our understanding of the rsync architecture, and
to pin-point any bottlenecks:</p>















<a href="https://michael.stapelberg.ch/posts/2022-07-02-rsync-how-does-it-work/2022-05-29-rsync-exo1-backup.jpg"><img
  srcset="https://michael.stapelberg.ch/posts/2022-07-02-rsync-how-does-it-work/2022-05-29-rsync-exo1-backup_hua2f50278895cfbee4dc18c7ea60b6d4a_2093260_1200x0_resize_q75_box.jpg 2x,https://michael.stapelberg.ch/posts/2022-07-02-rsync-how-does-it-work/2022-05-29-rsync-exo1-backup_hua2f50278895cfbee4dc18c7ea60b6d4a_2093260_1800x0_resize_q75_box.jpg 3x"
  src="https://michael.stapelberg.ch/posts/2022-07-02-rsync-how-does-it-work/2022-05-29-rsync-exo1-backup_hua2f50278895cfbee4dc18c7ea60b6d4a_2093260_600x0_resize_q75_box.jpg"
  
  width="600"
  height="331"
  style="

border: 1px solid #000;

"
  
  loading="lazy"></a>



<ol>
<li>phase: The rsync sender needs 17 seconds to walk the file system and send
the file list. The rsync receiver reads from the network and writes into RAM
during that time.
<ul>
<li>This phase is random I/O (querying file system metadata) for the sender.</li>
</ul>
</li>
<li>phase: Afterwards, the rsync sender reads from disk and sends to the
network. The rsync receiver receives from the network and writes to disk.
<ul>
<li>The receiver does roughly the same amount of random I/O as the sender did
in phase 1, as it needs to create directories and request missing files.</li>
<li>The sender does sequential disk reads and possibly checksum calculation, if
the file(s) existed on the receiver side.</li>
</ul>
</li>
</ol>
<p>(Again, the above was captured using rsync protocol version 27, later rsync
protocol versions don’t synchronize after completing phase 1, but instead
interleave the phases more.)</p>
<h3 id="rsync-hash-search">rsync hash search</h3>
<p>Up until now, we have described the rsync protocol at a high level. Let’s zoom
into the hash search step, which is what many people might associate with the
term “rsync algorithm”.</p>
<p>When a file exists on both sides, rsync sender and receiver, the receiver first
divides the file into blocks. The block size is a rounded square root of the
file’s length. The receiver then sends the checksums of all blocks to the
sender. In response, the sender finds matching blocks in the file and sends only
the data needed to reconstruct the file on the receiver side.</p>
<p>Specifically, the sender goes through <strong>each byte</strong> of the file and tries to
match existing receiver content. To make this less computationally expensive,
rsync combines two checksums.</p>
<p>rsync first calculates what it calls the
<a href="https://github.com/WayneD/rsync/blob/0ac7ebceef70417355f25daf9e2fd94e84c49749/checksum.c#L182-L203">“sum1”</a>,
or “fast signature”. This is a small checksum (two <code>uint16</code>) that can be
calculated with minimal effort for a rolling window over the file data. tridge
rsync comes with <a href="https://github.com/WayneD/rsync/blob/v3.2.4/simd-checksum-x86_64.cpp">SIMD
implementations</a>
to further speed this up where possible.</p>
<p>Only if the sum1 matches will
<a href="https://github.com/WayneD/rsync/blob/0ac7ebceef70417355f25daf9e2fd94e84c49749/checksum.c#L205-L300">“sum2”</a>
(or “strong signature”) be calculated, a 16-byte MD4 hash. Newer protocol
versions allow negotiating the hash algorithm and support the much faster xxhash
algorithms.</p>
<p>If sum2 matches, the block is considered equal on both sides.</p>
<p>Hence, the best case for rsync is when a file has either not changed at all, or
shares as many full blocks of content as possible with the old contents.</p>
<h2 id="changing-data-sets">Changing data sets</h2>
<p>Now that we know how rsync works on the file level, let’s take a step back to
the data set level.</p>
<p>The easiest situation is when you transfer a data set that is not currently
changing. But what happens when the data set changes while your rsync transfer
is running? Here are two examples.</p>
<p><a href="https://github.com/Debian/debiman">debiman</a>, the manpage generator powering
<a href="https://manpages.debian.org/">manpages.debian.org</a> is running on a Debian VM on
which an rsync job periodically transfers the static manpage archive to
different static web servers across the world. The rsync job and debiman are
not sequenced in any way. Instead, debiman is careful to only ever <a href="https://github.com/Debian/debiman/blob/79b8abe8573daaaf15e4cf40e85daf309e00d454/internal/write/atomically.go#L23">atomically
swap out
files</a>
in its output directory, or add new files before it swaps out an updated index.</p>
<p>The second example, the <a href="https://en.wikipedia.org/wiki/PostgreSQL">PostgreSQL</a>
database management system, is the opposite situation: instead of having full
control over how files are laid out, here I don’t have control over how files
are written (this generalizes to any situation where the model of only ever
replacing files is not feasible). The data files which my Postgres installation
keeps on disk are not great to synchronize using rsync: they are large and
frequently change. Instead, I now exempt them from my rsync transfer and use <a href="https://manpages.debian.org/pg_dump.1"><code>pg_dump(1)</code></a>
 to create a snapshot of my databases instead.</p>
<p>To confirm rsync’s behavior regarding changing data sets in detail, I <a href="#confirmation-hack">modified
rsync to ask for confirmation</a> between generating the file
list and transferring the files. Here’s what I found:</p>
<ul>
<li>If files are added after rsync has transferred the file list, the new files
will just not be part of the transfer.</li>
<li>If a file vanishes between generating the file list and transfering the file,
rsync exits with status code 24, which <a href="https://manpages.debian.org/bullseye/rsync/rsync.1.en.html#EXIT_VALUES">its manpage documents as “Partial
transfer due to vanished source
files”</a>. My
<code>rsyncprom</code> monitoring wrapper <a href="https://github.com/stapelberg/rsyncprom/commit/bbf82934093b938d054d460a7f9764234d30bc17">offers a flag to treat exit code 24 like exit
code
0</a>,
because depending on the data set, vanishing files are expected.</li>
<li>If a file’s contents change (no matter whether the file grows, shrinks, or is
modified in-place) between generating the file list and the actual file
transfer, that’s not a problem — rsync will transfer the file contents as it
reads them once the transfer starts. Note that this might be an inconsistent
view of the data, depending on the application.
<ul>
<li>Ideally, don’t ever modify files within a data set that is rsynced. Instead,
atomically move complete files into the data set.</li>
</ul>
</li>
</ul>
<p>Another way of phrasing the above is that data consistency is not something that
rsync can in any way guarantee. It’s up to you to either live with the
inconsistency (often a good-enough strategy!), or to add an extra step that
ensures the data set you feed to rsync is consistent.</p>
<h2 id="next-up">Next up</h2>
<p>The fourth article in this series is rsync, article 4: My own rsync
implementation (To be published.)</p>
<h2 id="confirmation-hack">Appendix A: rsync confirmation hack</h2>
<p>For verifying rsync’s behavior with regards to changing data sets, I checked
out the following version:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>% git clone https://github.com/WayneD/rsync/ rsync-changing-data-sets
</span></span><span style="display:flex;"><span>% <span style="color:#007020">cd</span> rsync-changing-data-sets
</span></span><span style="display:flex;"><span>% git checkout v3.2.4
</span></span><span style="display:flex;"><span>% ./configure
</span></span><span style="display:flex;"><span>% make
</span></span></code></pre></div><p>Then, I modified <code>flist.c</code> to add a confirmation step between sending the file
list and doing the actual file transfers:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">diff --git i/flist.c w/flist.c
</span></span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">index 1ba306bc..98981f34 100644
</span></span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold"></span><span style="color:#a00000">--- i/flist.c
</span></span></span><span style="display:flex;"><span><span style="color:#a00000"></span><span style="color:#00a000">+++ w/flist.c
</span></span></span><span style="display:flex;"><span><span style="color:#00a000"></span><span style="color:#800080;font-weight:bold">@@ -20,6 +20,8 @@
</span></span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold"></span>  * with this program; if not, visit the http://fsf.org website.
</span></span><span style="display:flex;"><span>  */
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#00a000">+#include &lt;stdio.h&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#00a000">+
</span></span></span><span style="display:flex;"><span><span style="color:#00a000"></span> #include &#34;rsync.h&#34;
</span></span><span style="display:flex;"><span> #include &#34;ifuncs.h&#34;
</span></span><span style="display:flex;"><span> #include &#34;rounding.h&#34;
</span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold">@@ -2516,6 +2518,17 @@ struct file_list *send_file_list(int f, int argc, char *argv[])
</span></span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold"></span> 	if (DEBUG_GTE(FLIST, 2))
</span></span><span style="display:flex;"><span> 		rprintf(FINFO, &#34;send_file_list done\n&#34;);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#00a000">+	char *line = NULL;
</span></span></span><span style="display:flex;"><span><span style="color:#00a000">+	size_t llen = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#00a000">+	ssize_t nread;
</span></span></span><span style="display:flex;"><span><span style="color:#00a000">+	printf(&#34;file list sent. enter &#39;yes&#39; to continue: &#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#00a000">+	while ((nread = getline(&amp;line, &amp;llen, stdin)) != -1) {
</span></span></span><span style="display:flex;"><span><span style="color:#00a000">+	  if (nread == strlen(&#34;yes\n&#34;) &amp;&amp; strcasecmp(line, &#34;yes\n&#34;) == 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#00a000">+	    break;
</span></span></span><span style="display:flex;"><span><span style="color:#00a000">+	  }
</span></span></span><span style="display:flex;"><span><span style="color:#00a000">+	  printf(&#34;enter &#39;yes&#39; to continue: &#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#00a000">+	}
</span></span></span><span style="display:flex;"><span><span style="color:#00a000">+
</span></span></span><span style="display:flex;"><span><span style="color:#00a000"></span> 	if (inc_recurse) {
</span></span><span style="display:flex;"><span> 		send_dir_depth = 1;
</span></span><span style="display:flex;"><span> 		add_dirs_to_tree(-1, flist, stats.num_dirs);
</span></span></code></pre></div><p>My rsync invocation is:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>./rsync -av --debug<span style="color:#666">=</span>all4 --protocol<span style="color:#666">=</span><span style="color:#40a070">27</span> ~/i3/src /tmp/DEST/
</span></span></code></pre></div><p>It’s necessary to use an older protocol version to make rsync generate a full
file list before starting the transfer. Later protocol versions interleave these
parts of the protocol.</p>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[rsync, article 2: Surroundings]]></title>
    <link href="https://michael.stapelberg.ch/posts/2022-07-02-rsync-surroundings/"/>
    <id>https://michael.stapelberg.ch/posts/2022-07-02-rsync-surroundings/</id>
    <published>2022-07-02T14:30:00+02:00</published>
    <content type="html"><![CDATA[<p>This post is the second article in a series of blog posts about rsync, <a href="../2022-06-18-rsync-overview/">see the
Series Overview</a>.</p>
<p>Now that we know what to use rsync for, how can we best integrate rsync into
monitoring and alerting, and on which operating systems does it work?</p>
<h2 id="monitoring-and-alerting-for-rsync-jobs-using-prometheus">Monitoring and alerting for rsync jobs using Prometheus</h2>
<p>Once you have one or two important <code>rsync</code> jobs, it might make sense to alert
when your job has not completed as expected.</p>
<p>I’m using <a href="https://prometheus.io/">Prometheus</a> for all my monitoring and alerting.</p>
<p>Because Prometheus <em>pulls</em> metrics from its (typically always-running) targets,
we need an extra component: the <a href="https://prometheus.io/docs/practices/pushing/">Prometheus
Pushgateway</a>. The Pushgateway
stores metrics pushed by short-lived jobs like <code>rsync</code> transfers and makes them
available to subsequent Prometheus pulls.</p>
<p>To integrate <code>rsync</code> with the Prometheus Pushgateway, I wrote
<a href="https://github.com/stapelberg/rsyncprom"><code>rsyncprom</code></a>, a small tool that wraps
<code>rsync</code>, or parses rsync output supplied by you. Once <code>rsync</code> completes,
<code>rsyncprom</code> pushes the rsync exit code and parsed statistics about the transfer
to your Pushgateway.</p>
<h3 id="prometheus-server-side-setup">Prometheus server-side setup</h3>
<p>First, I set up the Prometheus Pushgateway (via Docker and systemd) on my
server.</p>
<p>Then, in my <code>prometheus.conf</code> file, I instruct Prometheus to pull data from my
Pushgateway:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#60a0b0;font-style:italic"># prometheus.conf</span><span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span><span style="color:#062873;font-weight:bold">rule_files</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span>- backups.rules.yml<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span><span style="color:#062873;font-weight:bold">scrape_configs</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span><span style="color:#60a0b0;font-style:italic"># […]</span><span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span>- <span style="color:#062873;font-weight:bold">job_name</span>:<span style="color:#bbb"> </span>pushgateway<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">  </span><span style="color:#062873;font-weight:bold">honor_labels</span>:<span style="color:#bbb"> </span><span style="color:#007020;font-weight:bold">true</span><span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">  </span><span style="color:#062873;font-weight:bold">static_configs</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">  </span>- <span style="color:#062873;font-weight:bold">targets</span>:<span style="color:#bbb"> </span>[<span style="color:#4070a0">&#39;pushgateway:9091&#39;</span>]<span style="color:#bbb">
</span></span></span></code></pre></div><p>Finally, in <code>backups.rules.yml</code>, I configure an alert on the time series <code>rsync_exit_code</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#60a0b0;font-style:italic"># backups.rules.yml</span><span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span><span style="color:#062873;font-weight:bold">groups</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span>- <span style="color:#062873;font-weight:bold">name</span>:<span style="color:#bbb"> </span>backups.rules<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">  </span><span style="color:#062873;font-weight:bold">rules</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">  </span>- <span style="color:#062873;font-weight:bold">alert</span>:<span style="color:#bbb"> </span>RsyncFailing<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#062873;font-weight:bold">expr</span>:<span style="color:#bbb"> </span>rsync_exit_code{job=&#34;rsync&#34;} &gt; 0<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#062873;font-weight:bold">for</span>:<span style="color:#bbb"> </span>1m<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#062873;font-weight:bold">labels</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">      </span><span style="color:#062873;font-weight:bold">job</span>:<span style="color:#bbb"> </span>rsync<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#062873;font-weight:bold">annotations</span>:<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">      </span><span style="color:#062873;font-weight:bold">description</span>:<span style="color:#bbb"> </span>rsync {{ $labels.instance }} is failing<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">      </span><span style="color:#062873;font-weight:bold">summary</span>:<span style="color:#bbb"> </span>rsync {{ $labels.instance }} is failing<span style="color:#bbb">
</span></span></span></code></pre></div><p>This alert will fire any time an rsync job monitored via <code>rsyncprom</code> exits with
a non-zero exit code.</p>
<h3 id="rsync-client-side-setup">rsync client-side setup</h3>
<p>On each machine that runs <code>rsync</code> jobs I want to monitor, I first install
<code>rsyncprom</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>go install github.com/stapelberg/rsyncprom/cmd/rsync-prom@latest
</span></span></code></pre></div><p>Then, I just wrap <code>rsync</code> transfers where it’s most convenient, for example in
my <a href="https://manpages.debian.org/crontab.5"><code>crontab(5)</code></a>
:</p>
<pre tabindex="0"><code class="language-crontab" data-lang="crontab"># crontab -e
9 9 * * * /home/michael/go/bin/rsync-prom --job=&#34;cron&#34; --instance=&#34;gphotos-sync@midna&#34; -- /home/michael/gphotos-sync/sync.sh
</code></pre><p>The same wrapper technique works in <a href="https://github.com/stapelberg/rsyncprom#setup-example-systemd">shell scripts or systemd service
files</a>.</p>
<p>You can also provide <code>rsync</code> output <a href="https://github.com/stapelberg/zkj-nas-tools/blob/02d46d718df60c413844d9218f6dd702ad94e5f1/dornroeschen/sshutil.go#L134-L139">from Go
code</a>
(this example runs <code>rsync</code> via SSH).</p>
<h3 id="monitoring-architecture">Monitoring architecture</h3>
<p>Here’s how the whole setup looks like architecturally:</p>
<p><img src="2022-05-29-rsync-prom-architecture.svg" alt="rsync-prom architecture"></p>
<p>The rsync scheduler runs on a Raspberry Pi running
<a href="https://gokrazy.org/">gokrazy</a>. The scheduler invokes the <code>rsync</code> job to back
up <em>websrv.zekjur.net</em> via SSH and sends the output to Prometheus, which is
running on a (different) server at an ISP.</p>
<h3 id="monitoring-dashboard">Monitoring dashboard</h3>
<p>The grafana dashboard looks like this in action:</p>















<a href="https://michael.stapelberg.ch/posts/2022-07-02-rsync-surroundings/2022-06-12-rsync-grafana-featured.jpg"><img
  srcset="https://michael.stapelberg.ch/posts/2022-07-02-rsync-surroundings/2022-06-12-rsync-grafana-featured_hu49255cbd0611171ac9ea093d82565708_603964_1200x0_resize_q75_box.jpg 2x,https://michael.stapelberg.ch/posts/2022-07-02-rsync-surroundings/2022-06-12-rsync-grafana-featured_hu49255cbd0611171ac9ea093d82565708_603964_1800x0_resize_q75_box.jpg 3x"
  src="https://michael.stapelberg.ch/posts/2022-07-02-rsync-surroundings/2022-06-12-rsync-grafana-featured_hu49255cbd0611171ac9ea093d82565708_603964_600x0_resize_q75_box.jpg"
  alt="rsync grafana dashboard" title="rsync grafana dashboard"
  width="600"
  height="469"
  style="

border: 1px solid #000;

"
  
  loading="lazy"></a>



<ul>
<li>The top left table shows the most recent rsync exit code, green means 0 (success).</li>
<li>The top right graph shows rsync runtime (wall-clock time) over time. Long
runtime can have any number of bottlenecks as the reason: network connections,
storage devices, slow CPUs.</li>
<li>The bottom left graph shows rsync dataset size over time. This allows you to
quickly pinpoint transfers that are filling your disk up.</li>
<li>The bottom right graph shows transferred bytes per rsync over time. The higher
the value, the higher the amount of change in your data set between
synchronization runs.</li>
</ul>
<h2 id="rsync-operating-system-availability">rsync operating system availability</h2>
<p>Now that we have learnt about a couple of typical use-cases, where can you use
<code>rsync</code> to implement these use-cases? The answer is: in most environments, as
<code>rsync</code> is widely available on different Linux and BSD versions.</p>
<p>Macs come with <code>rsync</code> available by default (but it’s an old, patched version),
and OpenBSD comes with a BSD-licensed implementation called
<a href="https://www.openrsync.org/">openrsync</a> by default.</p>
<p>On Windows, you can use the <a href="https://en.wikipedia.org/wiki/Windows_Subsystem_for_Linux">Windows Subsystem for
Linux</a>.</p>
<table>
<thead>
<tr>
<th>Operating System</th>
<th>Implementation</th>
<th>Version</th>
</tr>
</thead>
<tbody>
<tr>
<td>FreeBSD 13.1 (ports)</td>
<td>tridge</td>
<td><a href="https://www.freebsd.org/cgi/man.cgi?query=rsync&amp;manpath=FreeBSD+13.1-RELEASE+and+Ports">3.2.3</a></td>
</tr>
<tr>
<td>OpenBSD 7.1</td>
<td>openrsync</td>
<td>(7.1)</td>
</tr>
<tr>
<td>OpenBSD 7.1 (ports)</td>
<td>tridge</td>
<td><a href="https://openports.se/net/rsync">3.2.4</a></td>
</tr>
<tr>
<td>NetBSD 9.2 (pkgsrc)</td>
<td>tridge</td>
<td><a href="https://ftp.netbsd.org/pub/pkgsrc/current/pkgsrc/net/rsync/index.html">3.2.4</a></td>
</tr>
<tr>
<td>Linux</td>
<td>tridge</td>
<td><a href="https://repology.org/project/rsync/versions">repology</a></td>
</tr>
<tr>
<td>macOS</td>
<td>tridge</td>
<td><a href="https://www.unix.com/man-page/osx/1/rsync/">2.6.9</a></td>
</tr>
</tbody>
</table>
<h2 id="next-up">Next Up</h2>
<p>The third article in this series is <a href="../2022-07-02-rsync-how-does-it-work/">rsync, article 3: How does rsync
work?</a>. With rsync up and running, it’s
time to take a peek under the hood of rsync to better understand how it works.</p>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[rsync, article 1: Scenarios]]></title>
    <link href="https://michael.stapelberg.ch/posts/2022-06-18-rsync-article-1-scenarios/"/>
    <id>https://michael.stapelberg.ch/posts/2022-06-18-rsync-article-1-scenarios/</id>
    <published>2022-06-18T15:04:00+02:00</published>
    <content type="html"><![CDATA[<p>This post is the first article in a series of blog posts about rsync, <a href="../2022-06-18-rsync-overview/">see the
Series Overview</a>.</p>
<p>To motivate why it makes sense to look at rsync, I present three scenarios for
which I have come to appreciate rsync: <a href="#dokuwiki-transfers-using-rsync">DokuWiki
transfers</a>, <a href="#software-deployment-using-rsync">Software
deployment</a> and
<a href="#backups-using-rsync">Backups</a>.</p>
<h2 id="dokuwiki-transfers-using-rsync">Scenario: DokuWiki transfers using rsync</h2>
<p>Recently, I set up a couple of tools for a website that is built on DokuWiki,
such as a dead link checker and a statistics program. To avoid overloading the
live website (and possibly causing spurious requests that interfere with
statistics), I decided it would be best to run a separate copy of the DokuWiki
installation locally. This requires synchronizing:</p>
<ol>
<li>The PHP source code files of DokuWiki itself (including plugins and configuration)</li>
<li>One text file per wiki page, and all uploaded media files</li>
</ol>
<p>A DokuWiki installation is exactly the kind of file tree that <a href="https://manpages.debian.org/scp.1"><code>scp(1)</code></a>
 cannot efficiently transfer (too many small files),
but <a href="https://manpages.debian.org/rsync.1"><code>rsync(1)</code></a>
 can! The <code>rsync</code> transfer only takes a few seconds, no matter if
it’s a full download (can be simpler for batch jobs) or an incremental
synchronization (more efficient for regular synchronizations like backups).</p>
<h2 id="software-deployment-using-rsync">Scenario: Software deployment using rsync</h2>
<p>For smaller projects where I don’t publish new versions through Docker, I
instead use a shell script to transfer and run my software on the server.</p>
<p><code>rsync</code> is a great fit here, as it transfers many small files (static assets and
templates) efficiently, only transfers the binaries that actually changed, and
doesn’t mind if the binary file it’s uploading is currently running (contrary to
<a href="https://manpages.debian.org/scp.1"><code>scp(1)</code></a>
, for example).</p>
<p>To illustrate how such a script could look like, here’s my push script for
<a href="https://codesearch.debian.net/">Debian Code Search</a>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#007020">#!/bin/zsh
</span></span></span><span style="display:flex;"><span><span style="color:#007020"></span><span style="color:#007020">set</span> -ex
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#60a0b0;font-style:italic"># Asynchronously transfer assets while compiling:</span>
</span></span><span style="display:flex;"><span><span style="color:#666">(</span>
</span></span><span style="display:flex;"><span>    ssh root@dcs <span style="color:#4070a0">&#39;for i in $(seq 0 5); do mkdir -p /srv/dcs/shard${i}/{src,idx}; done&#39;</span>
</span></span><span style="display:flex;"><span>    ssh root@dcs <span style="color:#4070a0">&#34;adduser --disabled-password --gecos &#39;Debian Code Search&#39; dcs || true&#34;</span>
</span></span><span style="display:flex;"><span>    rsync -r systemd/ root@dcs:/etc/systemd/system/ &amp;
</span></span><span style="display:flex;"><span>    rsync -r cmd/dcs-web/templates/ root@dcs:/srv/dcs/templates/ &amp;
</span></span><span style="display:flex;"><span>    rsync -r static/ root@dcs:/srv/dcs/static/ &amp;
</span></span><span style="display:flex;"><span>    <span style="color:#007020">wait</span>
</span></span><span style="display:flex;"><span><span style="color:#666">)</span> &amp;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#60a0b0;font-style:italic"># Compile a new Debian Code Search version:</span>
</span></span><span style="display:flex;"><span><span style="color:#bb60d5">tmp</span><span style="color:#666">=</span><span style="color:#007020;font-weight:bold">$(</span>mktemp -d<span style="color:#007020;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>mkdir <span style="color:#bb60d5">$tmp</span>/bin
</span></span><span style="display:flex;"><span><span style="color:#bb60d5">GOBIN</span><span style="color:#666">=</span><span style="color:#bb60d5">$tmp</span>/bin <span style="color:#4070a0;font-weight:bold">\
</span></span></span><span style="display:flex;"><span><span style="color:#4070a0;font-weight:bold"></span><span style="color:#bb60d5">GOAMD64</span><span style="color:#666">=</span>v3 <span style="color:#4070a0;font-weight:bold">\
</span></span></span><span style="display:flex;"><span><span style="color:#4070a0;font-weight:bold"></span>  go install <span style="color:#4070a0;font-weight:bold">\
</span></span></span><span style="display:flex;"><span><span style="color:#4070a0;font-weight:bold"></span>  -ldflags <span style="color:#4070a0">&#39;-X github.com/Debian/dcs/cmd/dcs-web/common.Version=$version&#39;</span> <span style="color:#4070a0;font-weight:bold">\
</span></span></span><span style="display:flex;"><span><span style="color:#4070a0;font-weight:bold"></span>  github.com/Debian/dcs/cmd/...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#60a0b0;font-style:italic"># Transfer the Debian Code Search binaries:</span>
</span></span><span style="display:flex;"><span>rsync <span style="color:#4070a0;font-weight:bold">\
</span></span></span><span style="display:flex;"><span><span style="color:#4070a0;font-weight:bold"></span>  <span style="color:#bb60d5">$tmp</span>/bin/dcs-<span style="color:#666">{</span>web,source-backend,package-importer,compute-ranking,feeder<span style="color:#666">}</span> <span style="color:#4070a0;font-weight:bold">\
</span></span></span><span style="display:flex;"><span><span style="color:#4070a0;font-weight:bold"></span>  <span style="color:#bb60d5">$tmp</span>/bin/dcs <span style="color:#4070a0;font-weight:bold">\
</span></span></span><span style="display:flex;"><span><span style="color:#4070a0;font-weight:bold"></span>  root@dcs:/srv/dcs/bin/
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#60a0b0;font-style:italic"># Wait for the asynchronous asset transfer to complete:</span>
</span></span><span style="display:flex;"><span><span style="color:#007020">wait</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#60a0b0;font-style:italic"># Restart Debian Code Search on the server:</span>
</span></span><span style="display:flex;"><span><span style="color:#bb60d5">UNITS</span><span style="color:#666">=(</span>dcs-package-importer.service dcs-source-backend.service dcs-compute-ranking.timer dcs-web.service<span style="color:#666">)</span>
</span></span><span style="display:flex;"><span>ssh root@dcs systemctl daemon-reload <span style="color:#4070a0;font-weight:bold">\&amp;\&amp;</span> <span style="color:#4070a0;font-weight:bold">\
</span></span></span><span style="display:flex;"><span><span style="color:#4070a0;font-weight:bold"></span>  systemctl <span style="color:#007020">enable</span> <span style="color:#70a0d0">${</span><span style="color:#bb60d5">UNITS</span><span style="color:#70a0d0">}</span> <span style="color:#4070a0;font-weight:bold">\;</span> <span style="color:#4070a0;font-weight:bold">\
</span></span></span><span style="display:flex;"><span><span style="color:#4070a0;font-weight:bold"></span>  systemctl reset-failed <span style="color:#70a0d0">${</span><span style="color:#bb60d5">UNITS</span><span style="color:#70a0d0">}</span> <span style="color:#4070a0;font-weight:bold">\;</span> <span style="color:#4070a0;font-weight:bold">\
</span></span></span><span style="display:flex;"><span><span style="color:#4070a0;font-weight:bold"></span>  systemctl restart <span style="color:#70a0d0">${</span><span style="color:#bb60d5">UNITS</span><span style="color:#70a0d0">}</span> <span style="color:#4070a0;font-weight:bold">\;</span> <span style="color:#4070a0;font-weight:bold">\
</span></span></span><span style="display:flex;"><span><span style="color:#4070a0;font-weight:bold"></span>  systemctl reload nginx
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>rm -rf <span style="color:#4070a0">&#34;</span><span style="color:#70a0d0">${</span><span style="color:#bb60d5">tmp</span>?<span style="color:#70a0d0">}</span><span style="color:#4070a0">&#34;</span>
</span></span></code></pre></div><h2 id="backups-using-rsync">Scenario: Backups using rsync</h2>
<p>The first backup system I used was
<a href="https://en.wikipedia.org/wiki/Bacula">bacula</a>, which Wikipedia describes as an
enterprise-level backup system. That certainly matches my impression, both in
positive and negative ways: while bacula is very powerful, some seemingly common
operations turn out quite complicated in bacula. Restoring a single file or
directory tree from a backup was always more effort than I thought
reasonable. For some reason, I often had to restore backup catalogs before I was
able to access the backup contents (I don’t remember the exact details).</p>
<p>When moving apartment last time, I used the opportunity to change my backup
strategy. Instead of using complicated custom software with its own volume file
format (like bacula), I wanted backed-up files to be usable on the file system
level with standard tools like <code>rm</code>, <code>ls</code>, <code>cp</code>, etc.</p>
<p>Working with files in a regular file system makes day-to-day usage easier, and
also ensures that when my network storage hardware dies, I can just plug the
hard disk into any PC, boot a Linux live system, and recover my data.</p>
<p>To back up machines onto my <a href="/posts/2019-10-23-nas/">network storage PC</a>’s file
system, I ended up with a <a href="https://github.com/stapelberg/zkj-nas-tools/blob/85e445a284c89590d595a52e16cb6dd652b1388e/dornroeschen/backup-remote.pl">hand-written rsync wrapper
script</a>
that copies the full file system of each machine into dated directory trees:</p>
<pre tabindex="0"><code>storage2# ls -l backup/midna/2022-05-27
bin   boot  etc  home  lib  lib64  media  opt
proc  root  run  sbin  sys  tmp    usr    var

storage2# ls -l backup/midna/2022-05-27/home/michael/configfiles/zshrc
-rw-r--r--. 7 1000 1000 14554 May  9 19:37 backup/midna/2022-05-27/home/michael/configfiles/zshrc
</code></pre><p>To revert my <code>~/.zshrc</code> to an older version, I can <a href="https://manpages.debian.org/scp.1"><code>scp(1)</code></a>
 the file:</p>
<pre tabindex="0"><code>midna% scp storage2:/srv/backup/midna/2022-05-27/home/michael/configfiles/zshrc ~/configfiles/zshrc
</code></pre><p>To compare a whole older source tree, I can mount it using <a href="https://manpages.debian.org/sshfs.1"><code>sshfs(1)</code></a>
:</p>
<pre tabindex="0"><code>midna% mkdir /tmp/2022-05-27-i3
midna% sshfs storage2:/srv/backup/midna/2022-05-27/$HOME/i3 /tmp/2022-05-27-i3
midna% diff -ur /tmp/2022-05-27-i3 ~/i3/
</code></pre><h3 id="incremental-backups">Incremental backups</h3>
<p>Of course, the idea is not to transfer the full machine contents every day, as
that would quickly fill up my network storage’s 16 TB disk! Instead, we can use
rsync’s <code>--link-dest</code> option to elegantly deduplicate files using file system
hard links:</p>
<pre tabindex="0"><code>backup/midna/2022-05-26
backup/midna/2022-05-27 # rsync --link-dest=2022-05-26
</code></pre><p>To check the de-duplication level, we can use <a href="https://manpages.debian.org/du.1"><code>du(1)</code></a>
,
first on a single directory:</p>
<pre tabindex="0"><code>storage2# du -hs 2022-05-27 
113G	2022-05-27
</code></pre><p>…and then on two subsequent directories:</p>
<pre tabindex="0"><code>storage2# du -hs 2022-05-25 2022-05-27
112G	2022-05-25
7.3G	2022-05-27
</code></pre><p>As you can see, the 2022-05-27 backup took 7.3 GB of disk space, and 104.7 GB
were re-used from the previous backup(s).</p>
<p>To print all files which have changed since the last backup, we can use:</p>
<pre tabindex="0"><code>storage2# find 2022-05-27 -type f -links 1 -print
</code></pre><h3 id="limitation-file-system-compatibility">Limitation: file system compatibility</h3>
<p>A significant limitation of backups at the file level is that the destination
file system (network storage) needs to support all the file system features used
on the machines you are backing up.</p>
<p>For example, if you use <a href="https://help.ubuntu.com/community/FilePermissionsACLs">POSIX
ACLs</a> or <a href="https://wiki.archlinux.org/title/File_permissions_and_attributes#Extended_attributes">Extended
attributes</a>
(possibly for <a href="https://wiki.archlinux.org/title/Capabilities">Capabilities</a> or
<a href="https://wiki.archlinux.org/title/SELinux">SELinux</a>), you need to ensure that
your backup file system has these features enabled, and that you are using <a href="https://manpages.debian.org/rsync.1"><code>rsync(1)</code></a>
’s <code>--xattrs</code> (or <code>-X</code> for short) option.</p>
<p>This can turn from a pitfall into a dealbreaker as soon as multiple operating
systems are involved. For example, the <code>rsync</code> version on macOS has
<a href="https://github.com/apple-oss-distributions/rsync/blob/aa4e500aa53b9417014c718a5ff0e29215f08e48/rsync/generator.c#L1447">Apple-specific
code</a>
to work with Apple <a href="https://en.wikipedia.org/wiki/Resource_fork">resource forks</a>
and other extended attributes. It’s not clear to me whether macOS <code>rsync</code> can
send files to Linux <code>rsync</code>, restore them, and end up with the same system state.</p>
<p>Luckily, I am only interested in backing up Linux systems, or merely home
directories of non-Linux systems, where no extended attributes are used.</p>
<h3 id="downside-slow-bulk-operations-disk-usage-deletion">Downside: slow bulk operations (disk usage, deletion)</h3>
<p>The biggest downside of this architecture is that working with the directory
trees in bulk can be very slow, especially when using a hard disk instead of an
SSD. For example, deleting old backups can easily take many hours to multiple
days (!). Sure, you can just let the <code>rm</code> command run in the background, but
it’s annoying nevertheless.</p>
<p>Even merely calculating the disk space usage of each directory tree is a
painfully slow operation. I tried using stateful disk usage tools like
<a href="http://duc.zevv.nl/">duc</a>, but it <a href="https://github.com/zevv/duc/issues/240">didn’t work
reliably</a> on my backups.</p>
<p>In practice, I found that for tracking down large files, using <a href="https://manpages.debian.org/ncdu.1"><code>ncdu(1)</code></a>
 on any recent backup typically quickly shows the
large file. In one case, I found <code>var/lib/postgresql</code> to consume many
gigabytes. I excluded it in favor of using <a href="https://manpages.debian.org/pg_dump.1"><code>pg_dump(1)</code></a>
, which resulted in much smaller backups!</p>
<p>Unfortunately, even when using an SSD, determining which files take up most
space of a full backup takes a few minutes:</p>
<pre tabindex="0"><code>storage2# time du -hs backup/midna/2022-06-09
742G	backup/midna/2022-06-09

real	8m0.202s
user	0m11.651s
sys	2m0.731s
</code></pre><h3 id="backup-transport-ssh-and-scheduling">Backup transport (SSH) and scheduling</h3>
<p>To transfer data via <code>rsync</code> from the backup host to my network storage, I’m
using SSH.</p>
<p>Each machine’s SSH access is restricted in my network storage’s SSH <a href="https://manpages.debian.org/authorized_keys.5"><code>authorized_keys(5)</code></a>
 config file to not allow arbitrary
commands, but to perform just a specific operation. The only allowed operation
in my case is running <code>rrsync</code> (“restricted rsync”) in a container whose file
system only contains the backup host’s sub directory, e.g. .<code>websrv.zekjur.net</code>:</p>
<pre tabindex="0"><code>command=&#34;/bin/docker run --log-driver none -i -e SSH_ORIGINAL_COMMAND -v /srv/backup/websrv.zekjur.net:/srv/backup/websrv.zekjur.net stapelberg/docker-rsync /srv/backup/websrv.zekjur.net&#34;,no-port-forwarding,no-X11-forwarding ssh-ed25519 AAAAC3…
</code></pre><p>(The <a href="/posts/2016-11-21-gigabit-nas-coreos/#dockerfiles-rrsync-and-samba">corresponding <code>Dockerfile</code> can be found in my Gigabit NAS
article</a>.)</p>
<p>To trigger such an SSH-protected <code>rsync</code> transfer remotely, I’m using a small
custom scheduling program called
<a href="https://github.com/stapelberg/zkj-nas-tools/tree/master/dornroeschen">dornröschen</a>. The
program arranges for all involved machines to be powered on (using
<a href="https://en.wikipedia.org/wiki/Wake-on-LAN">Wake-on-LAN</a>) and then starts
<code>rsync</code> via <em>another operation-restricted SSH connection</em>.</p>
<p>You could easily replace this with a cron job if you don’t care about WOL.</p>
<p>The architecture looks like this:</p>
<p><img src="2022-05-29-backup-architecture.svg" alt="backup architecture"></p>
<p>The operation-restricted SSH connection on each backup host is configured in
SSH’s <a href="https://manpages.debian.org/authorized_keys.5"><code>authorized_keys(5)</code></a>
 config file:</p>
<pre tabindex="0"><code>command=&#34;/root/backup-remote.pl&#34;,no-port-forwarding,no-X11-forwarding ssh-ed25519 AAAAC3…
</code></pre><h2 id="next-up">Next up</h2>
<p>The second article in this series is <a href="../2022-07-02-rsync-surroundings/">rsync, article 2:
Surroundings</a>. Now that we know what to use
rsync for, how can we best integrate rsync into monitoring and alerting, and on
which operating systems does it work?</p>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[rsync: Series Overview]]></title>
    <link href="https://michael.stapelberg.ch/posts/2022-06-18-rsync-overview/"/>
    <id>https://michael.stapelberg.ch/posts/2022-06-18-rsync-overview/</id>
    <published>2022-06-18T15:00:00+02:00</published>
    <content type="html"><![CDATA[<p>For many years, I was only a casual user of
<a href="https://en.wikipedia.org/wiki/Rsync">rsync</a> and used it mostly for one-off file
transfers.</p>
<p>Over time, I found rsync useful in more and more cases, and would recommend
every computer user put this great tool into their toolbox 🛠 🧰 !</p>
<p>I’m publishing a series of blog posts about rsync:</p>
<ul>
<li><a href="../2022-06-18-rsync-article-1-scenarios/">rsync, article 1: Scenarios</a>. To
motivate why it makes sense to look at rsync, I present three scenarios for
which I have come to appreciate rsync: DokuWiki transfers, Software deployment
and Backups.</li>
<li><a href="../2022-07-02-rsync-surroundings/">rsync, article 2: Surroundings</a>. Now that
we know what to use rsync for, how can we best integrate rsync into monitoring
and alerting, and on which operating systems does it work?</li>
<li><a href="../2022-07-02-rsync-how-does-it-work">rsync, article 3: How does rsync
work?</a>. With rsync up and running, it’s
time to take a peek under the hood of rsync to better understand how it works.</li>
<li>rsync, article 4: My own rsync implementation (To be published.)</li>
</ul>
]]></content>
  </entry>
</feed>
