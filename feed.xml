<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Michael Stapelbergs Website</title>
  <link href="https://michael.stapelberg.ch/feed.xml" rel="self"/>
  <link href="https://michael.stapelberg.ch/"/>
  <updated>2017-12-11T10:05:00+01:00</updated>
  <id>https://michael.stapelberg.ch/</id>
  <generator>Hugo -- gohugo.io</generator>
  <entry>
    <title type="html"><![CDATA[Optional dependencies don’t work]]></title>
    <link href="https://michael.stapelberg.ch/posts/2019-05-23-optional-dependencies/"/>
    <id>https://michael.stapelberg.ch/posts/2019-05-23-optional-dependencies/</id>
    <published>2019-05-23T00:00:00+00:00</published>
    <updated>2019-05-23T14:55:17+02:00</updated>
    <content type="html"><![CDATA[

<p>In the i3 projects, we have always tried hard to avoid optional
dependencies. There are a number of reasons behind it, and as I have recently
encountered some of the downsides of optional dependencies firsthand, I
summarized my thoughts in this article.</p>

<h3 id="what-is-a-compile-time-optional-dependency">What is a (compile-time) optional dependency?</h3>

<p>When building software from source, most programming languages and build systems
support conditional compilation: different parts of the source code are compiled
based on certain conditions.</p>

<p>An optional dependency is conditional compilation hooked up directly to a knob
(e.g. command line flag, configuration file, …), with the effect that the
software can now be built without an otherwise required dependency.</p>

<p>Let’s walk through a few issues with optional dependencies.</p>

<h3 id="inconsistent-experience-in-different-environments">Inconsistent experience in different environments</h3>

<p>Software is usually not built by end users, but by packagers, at least when we
are talking about Open Source.</p>

<p>Hence, end users don’t see the knob for the optional dependency, they are just
presented with the fait accompli: their version of the software behaves
differently than other versions of the same software.</p>

<p>Depending on the kind of software, this situation can be made obvious to the
user: for example, if the optional dependency is needed to print documents, the
program can produce an appropriate error message when the user tries to print a
document.</p>

<p>Sometimes, this isn’t possible: when i3 introduced an optional dependency on
cairo and pangocairo, the behavior itself (rendering window titles) worked in
all configurations, but non-ASCII characters might break depending on whether i3
was compiled with cairo.</p>

<p>For users, it is frustrating to only discover in conversation that a program has
a feature that the user is interested in, but it’s not available on their
computer. For support, this situation can be hard to detect, and even harder to
resolve to the user’s satisfaction.</p>

<h3 id="packaging-is-more-complicated">Packaging is more complicated</h3>

<p>Unfortunately, many build systems don’t stop the build when optional
dependencies are not present. Instead, you sometimes end up with a broken build,
or, even worse: with a successful build that does not work correctly at runtime.</p>

<p>This means that packagers need to closely examine the build output to know which
dependencies to make available. In the best case, there is a summary of
available and enabled options, clearly outlining what this build will
contain. In the worst case, you need to infer the features from the checks that
are done, or work your way through the <code>--help</code> output.</p>

<p>The better alternative is to configure your build system such that it stops when
<em>any</em> dependency was not found, and thereby have packagers acknowledge each
optional dependency by explicitly disabling the option.</p>

<h3 id="untested-code-paths-bit-rot">Untested code paths bit rot</h3>

<p>Code paths which are not used will inevitably bit rot. If you have optional
dependencies, you need to test both the code path without the dependency and the
code path with the dependency. It doesn’t matter whether the tests are automated
or manual, the test matrix must cover both paths.</p>

<p>Interestingly enough, this principle seems to apply to all kinds of software
projects (but it slows down as change slows down): one might think that
important Open Source building blocks should have enough users to cover all
sorts of configurations.</p>

<p>However, consider this example: building cairo without libxrender results in all
GTK application windows, menus, etc. being displayed as empty grey
surfaces. Cairo does not fail to build without libxrender, but the code path
clearly is broken without libxrender.</p>

<h3 id="can-we-do-without-them">Can we do without them?</h3>

<p>I’m not saying optional dependencies should <em>never</em> be used. In fact, for
bootstrapping, disabling dependencies can save a lot of work and can sometimes
allow breaking circular dependencies. For example, in an early bootstrapping
stage, binutils can be compiled with <code>--disable-nls</code> to disable
internationalization.</p>

<p>However, optional dependencies are broken so often that I conclude they are
overused. Read on and see for yourself whether you would rather commit to best
practices or not introduce an optional dependency.</p>

<h3 id="best-practices">Best practices</h3>

<p>If you do decide to make dependencies optional, please:</p>

<ol>
<li>Set up automated testing for <strong>all</strong> code path combinations.</li>
<li>Fail the build until packagers explicitly pass a <code>--disable</code> flag.</li>
<li>Tell users their version is missing a dependency at runtime, e.g. in <code>--version</code>.</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[Winding down my Debian involvement]]></title>
    <link href="https://michael.stapelberg.ch/posts/2019-03-10-debian-winding-down/"/>
    <id>https://michael.stapelberg.ch/posts/2019-03-10-debian-winding-down/</id>
    <published>2019-03-10T00:00:00+00:00</published>
    <updated>2019-03-10T21:43:19+01:00</updated>
    <content type="html"><![CDATA[

<p>This post is hard to write, both in the emotional sense but also in the “I would
have written a shorter letter, but I didn’t have the time” sense. Hence, please
assume the best of intentions when reading it—it is not my intention to make
anyone feel bad about their contributions, but rather to provide some insight
into why my frustration level ultimately exceeded the threshold.</p>

<p>Debian has been in my life for well over 10 years at this point.</p>

<p>A few weeks ago, I have visited some old friends at the Zürich Debian meetup
after a multi-year period of absence. On my bike ride home, it occurred to me
that the topics of our discussions had remarkable overlap with my last visit. We
had a discussion about the merits of systemd, which took a detour to respect in
open source communities, returned to processes in Debian and eventually
culminated in democracies and their theoretical/practical failings. Admittedly,
that last one might be a Swiss thing.</p>

<p>I say this not to knock on the Debian meetup, but because it prompted me to
reflect on what feelings Debian is invoking lately and whether it’s still a good
fit for me.</p>

<p>So I’m finally making a decision that I should have made a long time ago: I am
winding down my involvement in Debian to a minimum.</p>

<h3 id="what-does-this-mean">What does this mean?</h3>

<p>Over the coming weeks, I will:</p>

<ul>
<li>transition packages to be team-maintained where it makes sense</li>
<li>remove myself from the <code>Uploaders</code> field on packages with other maintainers</li>
<li>orphan packages where I am the sole maintainer</li>
</ul>

<p>I will try to keep up best-effort maintenance of the
<a href="https://manpages.debian.org/">manpages.debian.org</a> service and the
<a href="https://codesearch.debian.net/">codesearch.debian.net</a> service, but any help
would be much appreciated.</p>

<p>For all intents and purposes, please treat me as permanently on vacation. I will
try to be around for administrative issues (e.g. permission transfers) and
questions addressed directly to me, permitted they are easy enough to answer.</p>

<h3 id="why">Why?</h3>

<p>When I joined Debian, I was still studying, i.e. I had luxurious amounts of
spare time. Now, over 5 years of full time work later, my day job taught me a
lot, both about what works in large software engineering projects and how I
personally like my computer systems. I am very conscious of how I spend the
little spare time that I have these days.</p>

<p>The following sections each deal with what I consider a major pain point, in no
particular order. Some of them influence each other—for example, if changes
worked better, we could have a chance at transitioning packages to be more
easily machine readable.</p>

<h4 id="change-process-in-debian">Change process in Debian</h4>

<p>The last few years, my current team at work conducted various smaller and larger
refactorings across the entire code base (touching thousands of projects), so we
have learnt a lot of valuable lessons about how to effectively do these
changes. It irks me that Debian works almost the opposite way in every regard. I
appreciate that every organization is different, but I think a lot of my points
do actually apply to Debian.</p>

<p>In Debian, packages are nudged in the right direction by a document called the
<a href="https://www.debian.org/doc/debian-policy/">Debian Policy</a>, or its programmatic
embodiment, lintian.</p>

<p>While it is great to have a lint tool (for quick, local/offline feedback), it is
even better to not require a lint tool at all. The team conducting the change
(e.g. the C++ team introduces a new hardening flag for all packages) should be
able to do their work transparent to me.</p>

<p>Instead, currently, all packages become lint-unclean, all maintainers need to
read up on what the new thing is, how it might break, whether/how it affects
them, manually run some tests, and finally decide to opt in. This causes a lot
of overhead and manually executed mechanical changes across packages.</p>

<p>Notably, the <strong>cost of each change</strong> is distributed onto the package maintainers in
the Debian model. At work, we have found that the opposite works better: if the
team behind the change is put in power to do the change for as many users as
possible, they can be significantly more efficient at it, which reduces the
total cost and time a lot. Of course, exceptions (e.g. a large project abusing a
language feature) should still be taken care of by the respective owners, but
the important bit is that the default should be the other way around.</p>

<p>Debian is <strong>lacking tooling for large changes</strong>: it is hard to programmatically
deal with packages and repositories (see the section below). The closest to
“sending out a change for review” is to open a bug report with an attached
patch. I thought the workflow for accepting a change from a bug report was too
complicated and started <a href="/posts/2016-07-17-mergebot/">mergebot</a>, but only Guido
ever signaled interest in the project.</p>

<p>Culturally, reviews and reactions are slow. There are no deadlines. I literally
sometimes get emails notifying me that a patch I sent out a few years ago (!!)
is now merged. This turns projects from a small number of weeks into many years,
which is a huge demotivator for me.</p>

<p>Interestingly enough, you can see artifacts of the slow online activity manifest
itself in the offline culture as well: I don’t want to be discussing systemd’s
merits 10 years after I first heard about it.</p>

<p>Lastly, changes can easily be slowed down significantly by holdouts who refuse
to collaborate. My canonical example for this is rsync, whose maintainer refused
my patches to make the package use debhelper purely out of personal preference.</p>

<p>Granting so much personal freedom to individual maintainers prevents us as a
project from raising the abstraction level for building Debian packages, which
in turn makes tooling harder.</p>

<p>How would things look like in a better world?</p>

<ol>
<li>As a project, we should strive towards more unification. Uniformity still
does not rule out experimentation, it just changes the trade-off from easier
experimentation and harder automation to harder experimentation and easier
automation.</li>
<li>Our culture needs to shift from “this package is my domain, how dare you
touch it” to a shared sense of ownership, where anyone in the project can
easily contribute (reviewed) changes without necessarily even involving
individual maintainers.</li>
</ol>

<p>To learn more about how successful large changes can look like, I recommend <a href="https://www.youtube.com/watch?v=TrC6ROeV4GI">my
colleague Hyrum Wright’s talk “Large-Scale Changes at Google: Lessons Learned
From 5 Yrs of Mass Migrations”</a>.</p>

<h4 id="fragmented-workflow-and-infrastructure">Fragmented workflow and infrastructure</h4>

<p>Debian generally seems to prefer decentralized approaches over centralized
ones. For example, individual packages are maintained in separate repositories
(as opposed to in one repository), each repository can use any SCM (git and svn
are common ones) or no SCM at all, and each repository can be hosted on a
different site. Of course, what you do in such a repository also varies subtly
from team to team, and even within teams.</p>

<p>In practice, non-standard hosting options are used rarely enough to not justify
their cost, but frequently enough to be a huge pain when trying to automate
changes to packages. Instead of using GitLab’s API to create a merge request,
you have to design an entirely different, more complex system, which deals with
intermittently (or permanently!) unreachable repositories and abstracts away
differences in patch delivery (bug reports, merge requests, pull requests,
email, …).</p>

<p>Wildly diverging workflows is not just a temporary problem either. I
participated in long discussions about different git workflows during DebConf
13, and gather that there were similar discussions in the meantime.</p>

<p>Personally, I cannot keep enough details of the different workflows in my
head. Every time I touch a package that works differently than mine, it
frustrates me immensely to re-learn aspects of my day-to-day.</p>

<p>After noticing workflow fragmentation in the Go packaging team (which I
started), I tried fixing this with the <a href="https://go-team.pages.debian.net/workflow-changes.html">workflow changes
proposal</a>, but did not
succeed in implementing it. The lack of effective automation and slow pace of
changes in the surrounding tooling despite my willingness to contribute time and
energy killed any motivation I had.</p>

<h4 id="old-infrastructure-package-uploads">Old infrastructure: package uploads</h4>

<p>When you want to make a package available in Debian, you upload GPG-signed files
via anonymous FTP. There are several batch jobs (the queue daemon, <code>unchecked</code>,
<code>dinstall</code>, possibly others) which run on fixed schedules (e.g. <code>dinstall</code> runs
at 01:52 UTC, 07:52 UTC, 13:52 UTC and 19:52 UTC).</p>

<p>Depending on timing, I estimated that you might wait for over 7 hours (!!)
before your package is actually installable.</p>

<p>What’s worse for me is that feedback to your upload is asynchronous. I like to
do one thing, be done with it, move to the next thing. The current setup
requires a many-minute wait and costly task switch for no good technical
reason. You might think a few minutes aren’t a big deal, but when all the time I
can spend on Debian per day is measured in minutes, this makes a huge difference
in perceived productivity and fun.</p>

<p>The last communication I can find about speeding up this process is <a href="https://lists.debian.org/debian-project/2008/12/msg00014.html">ganneff’s
post</a> from 2008.</p>

<p>How would things look like in a better world?</p>

<ol>
<li>Anonymous FTP would be replaced by a web service which ingests my package and
returns an authoritative accept or reject decision in its response.</li>
<li>For accepted packages, there would be a status page displaying the build
status and when the package will be available via the mirror network.</li>
<li>Packages should be available within a few minutes after the build completed.</li>
</ol>

<h4 id="old-infrastructure-bug-tracker">Old infrastructure: bug tracker</h4>

<p>I dread interacting with the Debian bug
tracker. <a href="https://en.wikipedia.org/wiki/Debbugs">debbugs</a> is a piece of software
(from 1994) which is only used by Debian and the GNU project these days.</p>

<p>Debbugs processes emails, which is to say it is asynchronous and cumbersome to
deal with. Despite running on the fastest machines we have available in Debian
(or so I was told when the subject last came up), its web interface loads very
slowly.</p>

<p>Notably, the web interface at bugs.debian.org is read-only. Setting up a working
email setup for
<a href="https://manpages.debian.org/stretch/reportbug/reportbug.1.en.html"><code>reportbug(1)</code></a>
or manually dealing with attachments is a rather big hurdle.</p>

<p>For reasons I don’t understand, every interaction with debbugs results in <a href="https://twitter.com/zekjur/status/1027995569770442752">many
different email <em>threads</em></a>.</p>

<p>Aside from the technical implementation, I also can never remember the different
ways that Debian uses pseudo-packages for bugs and processes. I need them rarely
enough to establish a mental model of how they are set up, or working memory of
how they are used, but frequently enough to be annoyed by this.</p>

<p>How would things look like in a better world?</p>

<ol>
<li>Debian would switch from a custom bug tracker to a (any) well-established
one.</li>
<li>Debian would offer automation around processes. It is great to have a
paper-trail and artifacts of the process in the form of a bug report, but the
primary interface should be more convenient (e.g. a web form).</li>
</ol>

<h4 id="old-infrastructure-mailing-list-archives">Old infrastructure: mailing list archives</h4>

<p>It baffles me that in 2019, we still don’t have a conveniently browsable
threaded archive of mailing list discussions. Email and threading is more widely
used in Debian than anywhere else, so this is somewhat
ironic. <a href="https://en.wikipedia.org/wiki/Gmane">Gmane</a> used to paper over this
issue, but Gmane’s availability over the last few years has been spotty, to say
the least (it is down as I write this).</p>

<p>I tried to contribute a threaded list archive, but our listmasters didn’t seem
to care or want to support the project.</p>

<h4 id="debian-is-hard-to-machine-read">Debian is hard to machine-read</h4>

<p>While it is obviously possible to deal with Debian packages programmatically,
the experience is far from pleasant. Everything seems slow and cumbersome. I
have picked just 3 quick examples to illustrate my point.</p>

<p><a href="https://github.com/Debian/debiman/">debiman</a> needs <a href="https://github.com/Debian/debiman/issues/12">help from
piuparts</a> in analyzing the
alternatives mechanism of each package to display the manpages of
e.g. <a href="https://manpages.debian.org/stretch/postgresql-client-9.6/psql.1.en.html"><code>psql(1)</code></a>. This
is because maintainer scripts modify the alternatives database by calling shell
scripts. Without actually installing a package, you cannot know which changes it
does to the alternatives database.</p>

<p><a href="https://github.com/Debian/pk4">pk4</a> needs to maintain its own cache to look up
package metadata based on the package name. Other tools parse the apt database
from scratch on every invocation. A proper database format, or at least a binary
interchange format, would go a long way.</p>

<p><a href="https://github.com/Debian/dcs/">Debian Code Search</a> wants to ingest new
packages as quickly as possible. There used to be a
<a href="https://github.com/fedora-infra/fedmsg">fedmsg</a> instance for Debian, but it no
longer seems to exist. It is unclear where to get notifications from for new
packages, and where best to fetch those packages.</p>

<h4 id="complicated-build-stack">Complicated build stack</h4>

<p>See my <a href="/posts/2016-11-25-build-tools/">“Debian package build tools”</a> post. It
really bugs me that the sprawl of tools is not seen as a problem by others.</p>

<h4 id="developer-experience-pretty-painful">Developer experience pretty painful</h4>

<p>Most of the points discussed so far deal with the experience in <em>developing
Debian</em>, but as I recently described in my post <a href="/posts/2019-02-15-debian-debugging-devex/">“Debugging experience in
Debian”</a>, the experience when
<em>developing using Debian</em> leaves a lot to be desired, too.</p>

<h4 id="i-have-more-ideas">I have more ideas</h4>

<p>At this point, the article is getting pretty long, and hopefully you got a rough
idea of my motivation.</p>

<p>While I described a number of specific shortcomings above, the final nail in the
coffin is actually the lack of a positive outlook. I have more ideas that seem
really compelling to me, but, based on how my previous projects have been going,
I don’t think I can make any of these ideas happen within the Debian project.</p>

<p>I intend to publish a few more posts about specific ideas for improving
operating systems here. Stay tuned.</p>

<p>Lastly, I hope this post inspires someone, ideally a group of people, to improve
the developer experience within Debian.</p>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[Debugging experience in Debian]]></title>
    <link href="https://michael.stapelberg.ch/posts/2019-02-15-debian-debugging-devex/"/>
    <id>https://michael.stapelberg.ch/posts/2019-02-15-debian-debugging-devex/</id>
    <published>2019-02-15T00:00:00+00:00</published>
    <updated>2019-02-15T13:11:24+01:00</updated>
    <content type="html"><![CDATA[

<p>Recently, a user reported that <a href="https://bugs.debian.org/918925">they don’t see window titles in i3 when running
i3 on a Raspberry Pi with Debian</a>.</p>

<p>I copied the latest <a href="https://wiki.debian.org/RaspberryPi3">Raspberry Pi Debian
image</a> onto an SD card, booted it, and was
able to reproduce the issue.</p>

<p>Conceptually, at this point, I should be able to install and start <code>gdb</code>, set a
break point and step through the code.</p>

<h3 id="enabling-debug-symbols-in-debian">Enabling debug symbols in Debian</h3>

<p>Debian, by default, strips debug symbols when building packages to conserve disk
space and network bandwidth. The motivation is very reasonable: most users will
never need the debug symbols.</p>

<p>Unfortunately, obtaining debug symbols when you do need them is unreasonably hard.</p>

<p>We begin by configuring an additional apt repository which contains
automatically generated debug packages:</p>

<pre><code>raspi# cat &gt;&gt;/etc/apt/sources.list.d/debug.list &lt;&lt;'EOT'
deb http://deb.debian.org/debian-debug buster-debug main contrib non-free
EOT
raspi# apt update
</code></pre>

<p>Notably, not all Debian packages have debug packages. As <a href="https://wiki.debian.org/DebugPackage">the DebugPackage
Debian Wiki page</a> explains,
<code>debhelper/9.20151219</code> started generating debug packages (ending in <code>-dbgsym</code>)
automatically. Packages which have not been updated might come with their own
debug packages (ending in <code>-dbg</code>) or might not preserve debug symbols at all!</p>

<p>Now that we <strong>can</strong> install debug packages, how do we know <strong>which ones</strong> we need?</p>

<h3 id="finding-debug-symbol-packages-in-debian">Finding debug symbol packages in Debian</h3>

<p>For debugging i3, we obviously need at least the <code>i3-dbgsym</code> package, but i3
uses a number of other libraries through whose code we may need to step.</p>

<p>The <code>debian-goodies</code> package ships a tool called
<a href="https://manpages.debian.org/testing/debian-goodies/find-dbgsym-packages.1.en.html">find-dbgsym-packages</a>
which prints the required packages to debug an executable, core dump or running
process:</p>

<pre><code>raspi# apt install debian-goodies
raspi# apt install $(find-dbgsym-packages $(which i3))
</code></pre>

<p>Now we should have symbol names and line number information available in
<code>gdb</code>. But for effectively stepping through the program, access to the source
code is required.</p>

<h3 id="obtaining-source-code-in-debian">Obtaining source code in Debian</h3>

<p>Naively, one would assume that <code>apt source</code> should be sufficient for obtaining
the source code of any Debian package. However, <code>apt source</code> defaults to the
package candidate version, not the version you have installed on your
system.</p>

<p>I have addressed this issue with the
<a href="https://manpages.debian.org/testing/pk4/pk4.1.en.html"><code>pk4</code></a> tool, which
defaults to the installed version.</p>

<p>Before we can extract any sources, we need to configure yet another apt
repository:</p>

<pre><code>raspi# cat &gt;&gt;/etc/apt/sources.list.d/source.list &lt;&lt;'EOT'
deb-src http://deb.debian.org/debian buster main contrib non-free
EOT
raspi# apt update
</code></pre>

<p>Regardless of whether you use <code>apt source</code> or <code>pk4</code>, one remaining problem is
the directory mismatch: the debug symbols contain a certain path, and that path
is typically not where you extracted your sources to. While debugging, you will
need to tell <code>gdb</code> about the location of the sources. This is tricky when you
debug a call across different source packages:</p>

<pre><code>(gdb) pwd
Working directory /usr/src/i3.
(gdb) list main
229     * the main loop. */
230     ev_unref(main_loop);
231   }
232 }
233
234 int main(int argc, char *argv[]) {
235  /* Keep a symbol pointing to the I3_VERSION string constant so that
236   * we have it in gdb backtraces. */
237  static const char *_i3_version __attribute__((used)) = I3_VERSION;
238  char *override_configpath = NULL;
(gdb) list xcb_connect
484	../../src/xcb_util.c: No such file or directory.
</code></pre>

<p>See <a href="https://sourceware.org/gdb/onlinedocs/gdb/Source-Path.html">Specifying Source
Directories</a> in the
gdb manual for the <code>dir</code> command which allows you to add multiple directories to
the source path. This is pretty tedious, though, and does not work for all
programs.</p>

<h3 id="positive-example-fedora">Positive example: Fedora</h3>

<p>While Fedora conceptually shares all the same steps, the experience on Fedora is
so much better: when you run <code>gdb /usr/bin/i3</code>, it will tell you what the next
step is:</p>

<pre><code># gdb /usr/bin/i3
[…]
Reading symbols from /usr/bin/i3...(no debugging symbols found)...done.
Missing separate debuginfos, use: dnf debuginfo-install i3-4.16-1.fc28.x86_64
</code></pre>

<p>Watch what happens when we run the suggested command:</p>

<pre><code># dnf debuginfo-install i3-4.16-1.fc28.x86_64
enabling updates-debuginfo repository
enabling fedora-debuginfo repository
[…]
Installed:
  i3-debuginfo.x86_64 4.16-1.fc28
  i3-debugsource.x86_64 4.16-1.fc28
Complete!
</code></pre>

<p>A single command understood our intent, enabled the required repositories and
installed the required packages, both for debug symbols and source code (stored
in e.g. <code>/usr/src/debug/i3-4.16-1.fc28.x86_64</code>). Unfortunately, <code>gdb</code> doesn’t
seem to locate the sources, which seems like a bug to me.</p>

<p>One downside of Fedora’s approach is that <code>gdb</code> will only print all required
dependencies once you actually run the program, so you may need to run multiple
<code>dnf</code> commands.</p>

<h3 id="in-an-ideal-world">In an ideal world</h3>

<p>Ideally, none of the manual steps described above would be necessary. It seems
absurd to me that so much knowledge is required to efficiently debug programs in
Debian. Case in point: I only learnt about <code>find-dbgsym-packages</code> a few days ago
when talking to one of its contributors.</p>

<p>Installing <code>gdb</code> should be all that a user needs to do. Debug symbols and
sources can be transparently provided through a lazy-loading FUSE file
system. If our build/packaging infrastructure assured predictable paths and
automated debug symbol extraction, we could have transparent, quick and reliable
debugging of all programs within Debian.</p>

<p>NixOS’s dwarffs is an implementation of this idea:
<a href="https://github.com/edolstra/dwarffs">https://github.com/edolstra/dwarffs</a></p>

<h3 id="conclusion">Conclusion</h3>

<p>While I agree with the removal of debug symbols as a general optimization, I
think every Linux distribution should strive to provide an entirely transparent
debugging experience: you should not even have to know that debug symbols are
not present by default. Debian really falls short in this regard.</p>

<p>Getting Debian to a fully transparent debugging experience requires a lot of
technical work and a lot of social convincing. In my experience,
programmatically working with the Debian archive and packages is tricky, and
ensuring that <em>all</em> packages in a Debian release have debug packages (let alone
predictable paths) seems entirely unachievable due to the fragmentation of
packaging infrastructure and holdouts blocking any progress.</p>

<p>My go-to example is <a href="https://sources.debian.org/src/rsync/3.1.3-5/debian/rules/">rsync’s
debian/rules</a>, which
intentionally (!) still has not adopted debhelper. It is not a surprise that
there are no debug symbols for <code>rsync</code> in Debian.</p>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[TurboPFor: an analysis]]></title>
    <link href="https://michael.stapelberg.ch/posts/2019-02-05-turbopfor-analysis/"/>
    <id>https://michael.stapelberg.ch/posts/2019-02-05-turbopfor-analysis/</id>
    <published>2019-02-05T09:00:00+01:00</published>
    <updated>2019-02-05T09:18:27+01:00</updated>
    <content type="html"><![CDATA[

<h3 id="motivation">Motivation</h3>

<p>I have recently been looking into speeding up Debian Code Search. As a quick
reminder, search engines answer queries by consulting an inverted index: a map
from term to documents containing that term (called a “posting list”). See <a href="https://codesearch.debian.net/research/bsc-thesis.pdf">the
Debian Code Search Bachelor
Thesis</a> (PDF) for a lot
more details.</p>

<p>Currently, Debian Code Search does not store positional information in its
index, i.e. the index can only reveal <em>that</em> a certain trigram is present in a
document, not <em>where</em> or <em>how often</em>.</p>

<p>From analyzing Debian Code Search queries, I knew that identifier queries (70%)
massively outnumber regular expression queries (30%). When processing identifier
queries, storing positional information in the index enables a significant
optimization: instead of identifying the possibly-matching documents and having
to read them all, we can determine matches from querying the index alone, no
document reads required.</p>

<p>This moves the bottleneck: having to read all possibly-matching documents
requires a lot of expensive random I/O, whereas having to decode long posting
lists requires a lot of cheap sequential I/O.</p>

<p>Of course, storing positions comes with a downside: the index is larger, and a
larger index takes more time to decode when querying.</p>

<p>Hence, I have been looking at various posting list compression/decoding
techniques, to figure out whether we could switch to a technique which would
retain (or improve upon!) current performance despite much longer posting lists
and produce a small enough index to fit on our current hardware.</p>

<h3 id="literature">Literature</h3>

<p>I started looking into this space because of Daniel Lemire’s <a href="https://lemire.me/blog/2017/09/27/stream-vbyte-breaking-new-speed-records-for-integer-compression/">Stream
VByte</a>
post. As usual, Daniel’s work is well presented, easily digestible and
accompanied by not just one, but multiple implementations.</p>

<p>I also looked for scientific papers to learn about the state of the art and
classes of different approaches in general. The best I could find is
<a href="https://dl.acm.org/citation.cfm?doid=2682862.2682870">Compression, SIMD, and Postings
Lists</a>. If you don’t have
access to the paper, I hear that
<a href="https://en.wikipedia.org/wiki/Sci-Hub">Sci-Hub</a> is helpful.</p>

<p>The paper is from 2014, and doesn’t include all algorithms. If you know of a
better paper, please let me know and I’ll include it here.</p>

<p>Eventually, I stumbled upon an algorithm/implementation called TurboPFor, which
the rest of the article tries to shine some light on.</p>

<h3 id="turbopfor">TurboPFor</h3>

<p>If you’re wondering: PFor stands for Patched Frame Of Reference and describes a
family of algorithms. The principle is explained e.g. in <a href="https://arxiv.org/pdf/1401.6399.pdf">SIMD Compression and
the Intersection of Sorted Integers (PDF)</a>.</p>

<p>The <a href="https://github.com/powturbo/TurboPFor">TurboPFor project’s README file</a>
claims that TurboPFor256 compresses with a rate of 5.04 bits per integer, and
can decode with 9400 MB/s on a single thread of an Intel i7-6700 CPU.</p>

<p>For Debian Code Search, we use unsigned integers of 32 bit (uint32), which
TurboPFor will compress into as few bits as required.</p>

<p>Dividing Debian Code Search’s file sizes by the total number of integers, I get
similar values, at least for the docid index section:</p>

<ul>
<li>5.49 bits per integer for the docid index section</li>
<li>11.09 bits per integer for the positions index section</li>
</ul>

<p>I can confirm the order of magnitude of the decoding speed, too. My benchmark
calls TurboPFor from Go via cgo, which introduces some overhead. To exclude disk
speed as a factor, data comes from the page cache. The benchmark sequentially
decodes all posting lists in the specified index, using as many threads as the
machine has cores¹:</p>

<ul>
<li>≈1400 MB/s on a  1.1 GiB docid index section</li>
<li>≈4126 MB/s on a 15.0 GiB position index section</li>
</ul>

<p>I think the numbers differ because the position index section contains larger
integers (requiring more bits). I repeated both benchmarks, capped to 1 GiB, and
decoding speeds still differed, so it is not just the size of the index.</p>

<p>Compared to Streaming VByte, a TurboPFor256 index comes in at just over half the
size, while still reaching 83% of Streaming VByte’s decoding speed. This seems
like a good trade-off for my use-case, so I decided to have a closer look at how
TurboPFor works.</p>

<p>① See <a href="https://github.com/stapelberg/goturbopfor/blob/d7954fb81e66080941891dccc27407d8496f65d9/cmd/gp4-verify/verify.go">cmd/gp4-verify/verify.go</a> run on an Intel i9-9900K.</p>

<h3 id="methodology">Methodology</h3>

<p>To confirm my understanding of the details of the format, I implemented a
pure-Go TurboPFor256 decoder. Note that it is intentionally <em>not optimized</em> as
its main goal is to use simple code to teach the TurboPFor256 on-disk format.</p>

<p>If you’re looking to use TurboPFor from Go, I recommend using cgo. cgo’s
function call overhead is about 51ns <a href="https://go-review.googlesource.com/c/go/+/30080">as of Go
1.8</a>, which will easily be
offset by TurboPFor’s carefully optimized, vectorized (SSE/AVX) code.</p>

<p>With that caveat out of the way, you can find my teaching implementation at
<a href="https://github.com/stapelberg/goturbopfor">https://github.com/stapelberg/goturbopfor</a></p>

<p>I verified that it produces the same results as TurboPFor’s <code>p4ndec256v32</code>
function for all posting lists in the Debian Code Search index.</p>

<h3 id="on-disk-format">On-disk format</h3>

<p>Note that TurboPFor does not fully define an on-disk format on its own. When
encoding, it turns a list of integers into a byte stream:</p>

<pre><code>size_t p4nenc256v32(uint32_t *in, size_t n, unsigned char *out);
</code></pre>

<p>When decoding, it decodes the byte stream into an array of integers, but needs
to know the number of integers in advance:</p>

<pre><code>size_t p4ndec256v32(unsigned char *in, size_t n, uint32_t *out);
</code></pre>

<p>Hence, you’ll need to keep track of the number of integers and length of the
generated byte streams separately. When I talk about on-disk format, I’m
referring to the byte stream which TurboPFor returns.</p>

<p>The TurboPFor256 format uses blocks of 256 integers each, followed by a trailing
block — if required — which can contain fewer than 256 integers:</p>

<p><img src="/turbopfor/ondisk.svgo.svg"></p>

<p>SIMD bitpacking is used for all blocks but the trailing block (which uses
regular bitpacking). This is not merely an implementation detail for decoding:
the on-disk structure is different for blocks which can be SIMD-decoded.</p>

<p>Each block starts with a 2 bit header, specifying the type of the block:</p>

<ul>
<li>11: <a href="#block-constant">constant</a></li>
<li>00: <a href="#block-bitpack">bitpacking</a></li>
<li>10: <a href="#block-bitpackex">bitpacking with exceptions (bitmap)</a></li>
<li>01: <a href="#block-bitpackvb">bitpacking with exceptions (variable byte)</a></li>
</ul>

<p>Each block type is explained in more detail in the following sections.</p>

<p>Note that none of the block types store the number of elements: you will always
need to know how many integers you need to decode. Also, you need to know in
advance how many bytes you need to feed to TurboPFor, so you will need some sort
of container format.</p>

<p>Further, TurboPFor automatically choses the best block type for each block.</p>

<h4 id="block-constant">Constant block</h4>

<p>A constant block (all integers of the block have the same value) consists of a
single value of a specified bit width ≤ 32. This value will be stored in each
output element for the block. E.g., after calling <code>decode(input, 3, output)</code>
with <code>input</code> being the constant block depicted below, output is <code>{0xB8912636,
0xB8912636, 0xB8912636}</code>.</p>

<p><img src="/turbopfor/block-constant.svgo.svg"></p>

<p>The example shows the maximum number of bytes (5). Smaller integers will use
fewer bytes: e.g. an integer which can be represented in 3 bits will only use 2
bytes.</p>

<h4 id="block-bitpack">Bitpacking block</h4>

<p>A bitpacking block specifies a bit width ≤ 32, followed by a stream of
bits. Each value starts at the Least Significant Bit (LSB), i.e. the 3-bit
values 0 (<code>000b</code>) and 5 (<code>101b</code>) are encoded as <code>101000b</code>.</p>

<p><img src="/turbopfor/block-bitpack.svgo.svg"></p>

<h4 id="block-bitpackex">Bitpacking with exceptions (bitmap) block</h4>

<p>The constant and bitpacking block types work well for integers which don’t
exceed a certain width, e.g. for a series of integers of width ≤ 5 bits.</p>

<p>For a series of integers where only a few values exceed an otherwise common
width (say, two values require 7 bits, the rest requires 5 bits), it makes sense
to cut the integers into two parts: value and exception.</p>

<p>In the example below, decoding the third integer <code>out2</code> (<code>000b</code>) requires
combination with exception <code>ex0</code> (<code>10110b</code>), resulting in <code>10110000b</code>.</p>

<p>The number of exceptions can be determined by summing the 1 bits in the bitmap
using the <a href="https://en.wikipedia.org/wiki/Hamming_weight">popcount instruction</a>.</p>

<p><img src="/turbopfor/block-bitpackex.svgo.svg"></p>

<h4 id="block-bitpackvb">Bitpacking with exceptions (variable byte)</h4>

<p>When the exceptions are not uniform enough, it makes sense to switch from
bitpacking to a variable byte encoding:</p>

<p><img src="/turbopfor/block-bitpackvb.svgo.svg"></p>

<h3 id="decoding-variable-byte">Decoding: variable byte</h3>

<p>The variable byte encoding used by the TurboPFor format is similar to the one
<a href="https://sqlite.org/src4/doc/trunk/www/varint.wiki">used by SQLite</a>, which is
described, alongside other common variable byte encodings, at
<a href="https://github.com/stoklund/varint">github.com/stoklund/varint</a>.</p>

<p>Instead of using individual bits for dispatching, this format classifies the
first byte (<code>b[0]</code>) into ranges:</p>

<ul>
<li>[0—176]: the value is <code>b[0]</code></li>
<li>[177—240]: a 14 bit value is in <code>b[0]</code> (6 high bits) and <code>b[1]</code> (8 low bits)</li>
<li>[241—248]: a 19 bit value is in <code>b[0]</code> (3 high bits), <code>b[1]</code> and <code>b[2]</code> (16 low bits)</li>
<li>[249—255]: a 32 bit value is in <code>b[1]</code>, <code>b[2]</code>, <code>b[3]</code> and possibly <code>b[4]</code></li>
</ul>

<p>Here is the space usage of different values:</p>

<ul>
<li>[0—176] are stored in 1 byte (as-is)</li>
<li>[177—16560] are stored in 2 bytes, with the highest 6 bits added to 177</li>
<li>[16561—540848] are stored in 3 bytes, with the highest 3 bits added to 241</li>
<li>[540849—16777215] are stored in 4 bytes, with 0 added to 249</li>
<li>[16777216—4294967295] are stored in 5 bytes, with 1 added to 249</li>
</ul>

<p>An overflow marker will be used to signal that encoding the
values would be less space-efficient than simply copying them
(e.g. if all values require 5 bytes).</p>

<p>This format is very space-efficient: it packs 0-176 into a single byte, as
opposed to 0-128 (most others). At the same time, it can be decoded very
quickly, as only the first byte needs to be compared to decode a value (similar
to PrefixVarint).</p>

<h3 id="decoding-bitpacking">Decoding: bitpacking</h3>

<h4 id="regular-bitpacking">Regular bitpacking</h4>

<p>In regular (non-SIMD) bitpacking, integers are stored on disk one after the
other, padded to a full byte, as a byte is the smallest addressable unit when
reading data from disk. For example, if you bitpack only one 3 bit int, you will
end up with 5 bits of padding.</p>

<p><img src="/turbopfor/bitpacking.svgo.svg"></p>

<h4 id="simd-bitpacking-256v32">SIMD bitpacking (256v32)</h4>

<p>SIMD bitpacking works like regular bitpacking, but processes 8 uint32
little-endian values at the same time, leveraging the <a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX instruction
set</a>. The following
illustration shows the order in which 3-bit integers are decoded from disk:</p>

<p><img src="/turbopfor/bitpacking256v32.svgo.svg"></p>

<h3 id="in-practice">In Practice</h3>

<p>For a Debian Code Search index, 85% of posting lists are short enough to only
consist of a trailing block, i.e. no SIMD instructions can be used for decoding.</p>

<p>The distribution of block types looks as follows:</p>

<ul>
<li>72% bitpacking with exceptions (bitmap)</li>
<li>19% bitpacking with exceptions (variable byte)</li>
<li>5% constant</li>
<li>4% bitpacking</li>
</ul>

<p>Constant blocks are mostly used for posting lists with just one entry.</p>

<h3 id="conclusion">Conclusion</h3>

<p>The TurboPFor on-disk format is very flexible: with its 4 different kinds of
blocks, chances are high that a very efficient encoding will be used for most
integer series.</p>

<p>Of course, the flip side of covering so many cases is complexity: the format and
implementation take quite a bit of time to understand — hopefully this article
helps a little! For environments where the C TurboPFor implementation cannot be
used, smaller algorithms might be simpler to implement.</p>

<p>That said, if you can use the TurboPFor implementation, you will benefit from a
highly optimized SIMD code base, which will most likely be an improvement over
what you’re currently using.</p>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[Docker and IPv6]]></title>
    <link href="https://michael.stapelberg.ch/posts/2018-12-12-docker-ipv6/"/>
    <id>https://michael.stapelberg.ch/posts/2018-12-12-docker-ipv6/</id>
    <published>2018-12-12T09:54:00+01:00</published>
    <updated>2018-12-12T09:55:59+01:00</updated>
    <content type="html"><![CDATA[

<p>My use-case is seemingly very simple: I want to run a webserver in a Docker
container, and it should be reachable via IPv4 and IPv6. The webserver has
multiple virtual hosts, some of which just serve static files, while others
proxy to, say, a <a href="https://grafana.com">Grafana</a> instance, which is also running
in a Docker container.</p>

<p>This article walks through the required steps, which are a bit cumbersome to
puzzle together from Docker’s official documentation.</p>

<p>I’m using documentation-only IPs (<a href="https://tools.ietf.org/html/rfc3849">RFC3849</a>
and <a href="https://tools.ietf.org/html/rfc5737">RFC5737</a>) throughout the
article. Let’s say that my provider gives me a routed IPv6 subnet
<code>2001:db8:13b:330::/64</code> and the IPv4 address <code>203.0.113.1</code>.</p>

<h3 id="enabling-ipv6-in-docker">Enabling IPv6 in Docker</h3>

<p>The Docker daemon defaults to IPv4-only. To enable IPv6, create the
configuration file <code>/etc/docker/daemon.json</code> with the following content:</p>

<pre><code>{
  &quot;ipv6&quot;: true,
  &quot;fixed-cidr-v6&quot;: &quot;2001:db8:13b:330:ffff::/80&quot;
}
</code></pre>

<p>After restarting the Docker daemon, containers will now get IPv6 addresses based
on their MAC address, which is picked sequentially from the range
<code>02:42:ac:11:00:00</code> to <code>02:42:ac:11:ff:ff</code>. That is, the first container you
start will use the IPv6 address <code>2001:db8:13b:330:ffff:0242:ac11:0002</code>.</p>

<h3 id="publishing-ports-and-remote-addresses">Publishing ports and remote addresses</h3>

<p>When publishing port 80 of a webserver, notice the remote address when accessing
the port via IPv4 and IPv6:</p>

<pre><code>% docker run -p 80:80 nginx
198.51.100.7 - - [12/Dec/2018:07:38:19 +0000] &quot;GET / HTTP/1.1&quot; 200 612
172.17.0.1 - - [12/Dec/2018:07:38:40 +0000] &quot;GET / HTTP/1.1&quot; 200 612
</code></pre>

<p>The first request (IPv4) has the correct remote address, but not the second one
(IPv6). This is because Docker publishes ports with
<a href="https://en.wikipedia.org/wiki/Network_address_translation">NAT</a> for IPv4, and a
TCP proxy for IPv6.</p>

<p>Of course, not having access to the actual remote address breaks rate limiting,
abuse blocking, address-based geo location, etc.</p>

<p>Some people resort to using Docker’s <code>host</code> network option, but that’s not a
good solution: your container will not be able to talk to other containers by
name anymore, so you will need lots of static, host-specific configuration.</p>

<p>A better solution is to only publish the port via IPv4 and connect to the
container’s IPv6 address directly:</p>

<pre><code>% docker run --publish 203.0.113.1:80:80 --name nginx nginx
</code></pre>

<p>You can obtain the container’s IPv6 address using:</p>

<pre><code>% docker inspect -f '{{.NetworkSettings.GlobalIPv6Address}}' nginx
</code></pre>

<h3 id="static-ipv6-addresses">Static IPv6 addresses</h3>

<p>Above, I explained that we need to use the container’s IPv6 address directly,
and that the address is derived from the MAC address, which is chosen
sequentially at container start time.</p>

<p>Having addresses depend on the order in which containers come up isn’t a robust
solution for my simple setup, where I want to statically configure a DNS record.</p>

<p>Docker allows specifying an IPv6 address, but only when you’re using a <a href="https://docs.docker.com/network/network-tutorial-standalone/#use-user-defined-bridge-networks">user-defined bridge network</a> with an IPv6 subnet carved out for the network, like so:</p>

<pre><code>% docker network create --subnet 2001:db8:13b:330:dd::/80 --ipv6 nginx

% docker run \
  --network nginx \
  --ip6 2001:db8:13b:330:dd:ff::1 \
  --publish 203.0.113.1:80:80 \
  nginx
</code></pre>

<p>Note that I’m using an IPv6 address from the far end of the address space
(<code>ff::1</code>), so as to not conflict with the addresses that Docker sequentially
allocates from the network we created.</p>

<p>Now, create a DNS record with the container’s addresses and you’ll be able to
access it via IPv4 and IPv6 with correct remote addresses, while still being
able to reach other containers:</p>

<pre><code>www.example.net A    203.0.113.1
www.example.net AAAA 2001:db8:13b:330:dd:ff::1
</code></pre>

<p>Note that all other Docker containers that you want to reach from the nginx
container must also use the nginx network. This is the recommended solution over
the old <code>--link</code> flag anyway.</p>

<p>One disadvantage of this solution is that you cannot offer services from
multiple Docker containers on the same IPv6 address (e.g. www and git).</p>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[Network setup for our retro computing event RGB2Rv18]]></title>
    <link href="https://michael.stapelberg.ch/posts/2018-10-31-rgb2rv18-network/"/>
    <id>https://michael.stapelberg.ch/posts/2018-10-31-rgb2rv18-network/</id>
    <published>2018-10-30T23:00:00+01:00</published>
    <updated>2019-01-26T23:11:13+01:00</updated>
    <content type="html"><![CDATA[

<p>Our computer association <a href="https://www.noname-ev.de/">NoName e.V.</a> organizes a
retro computing event called <a href="https://www.rgb2r.de/">RGB2R</a> every year,
located in Heidelberg, Germany. This year’s version is called RGB2Rv18.</p>

<p>This article describes the network setup I created for this year’s event. If you
haven’t read it, the article about <a href="/posts/2017-11-13-rgb2r-network/">last year’s RGB2Rv17
network</a> is also available.</p>

<h3 id="connectivity">Connectivity</h3>

<p>As a reminder, the venue’s DSL connection tops out at a megabit or two, so we
used my parent’s 400 Mbit/s cable internet line, like last year.</p>

<p>A difference to last year is that we switched from the tp-link CPE510 devices to
a pair of <a href="https://www.ubnt.com/airfiber/airfiber24/">Ubiquiti airFiber24</a>. The
airFibers are specified to reach 1.4 Gbit/s. In practice, we reached
approximately 700 Mbps displayed capacity (at a signal strength of ≈-60 dBm) and
422 Mbit/s end-to-end download speed, limited by the cable uplink.</p>

<p>Notably, using a single pair of radios removes a bunch of complexity from the
network setup as we no longer need to load-balance over two separate uplinks.</p>

<p>Like last year, the edge router for the event venue was a <a href="https://pcengines.ch/apu2c4.htm">PC Engines
apu2c4</a>. For the Local Area Network (LAN)
within the venue, we provided a few switches and WiFi using <a href="https://www.ubnt.com/">Ubiquiti
Networks</a> access points.</p>

<h3 id="wifi-setup">WiFi setup</h3>

<p>It turns out that the 24 GHz-based airFiber radios are much harder to align than
the 5 GHz-based tp-links we used last year. With the tp-link devices, we were
able to easily obtain a link, and do maybe 45 minutes of fine tuning to achieve
maximum bandwidth.</p>

<p>With the airFiber radios mounted in the same location, we were unable to
establish a link even once in about 1.5 hours of trying. We think this was due
to trees/branches being in the way, so we decided to scout the property for a
better radio location with as much of a direct line of sight as possible.</p>

<p>We eventually found a better location on the other side of the house and managed
to establish a link. It still took us an hour or so of fine tuning to move the
link from weak (≈-80 dBm) to okay (≈-60 dBm).</p>

<p>After the first night, in which it rained for a while, the radios had lost their
link. We think that this might be due to the humidity, and managed to restore
the link after another 30 minutes of re-adjustment.</p>

<p>It also rained the second night, but this time, the link stayed up. During rain,
signal strength dropped from ≈-60 dBm to ≈-72 dBm, but that still resulted in
≈500 Mbit/s of WiFi capacity, sufficient to max out our uplink.</p>

<p>For next year, it would be great to use an antenna alignment tool of sorts to
cut down on setup time. Alternatively, we could switch to more forgiving radios
which also handle 500 Mbps+. Let me know if you have any suggestions!</p>

<h3 id="software">Software</h3>

<p>In May this year, I wrote <a href="https://github.com/rtr7/router7">router7</a>, a pure-Go
small home internet router. Mostly out of curiosity, we gave it a shot, and I’m
happy to announce that router7 ran the event without any trouble.</p>

<p>In preparation, I <a href="https://github.com/rtr7/router7/commit/2e8e0daa0ac8a6a123893b27fb1de566768383d0">implemented TCP MSS
clamping</a>
and <a href="https://github.com/rtr7/kernel/commit/c7afbc1fd2efdb9e1149d271c4d2be59cc5c98f4">included the WireGuard kernel
module</a>.</p>

<p>I largely followed the <a href="https://github.com/rtr7/router7#installation">router7 installation
instructions</a>. To be specific,
here is the <code>Makefile</code> I used for creating the router7 image:</p>

<pre><code># github.com/rtr7/router7/cmd/... without dhcp6,
# as the cable uplink does not provide IPv6:
PKGS := github.com/rtr7/router7/cmd/backupd \
	github.com/rtr7/router7/cmd/captured \
	github.com/rtr7/router7/cmd/dhcp4 \
	github.com/rtr7/router7/cmd/dhcp4d \
	github.com/rtr7/router7/cmd/diagd \
	github.com/rtr7/router7/cmd/dnsd \
	github.com/rtr7/router7/cmd/netconfigd \
	github.com/rtr7/router7/cmd/radvd \
	github.com/gokrazy/breakglass \
	github.com/gokrazy/timestamps \
	github.com/stapelberg/rgb2r/cmd/grafana \
	github.com/stapelberg/rgb2r/cmd/prometheus \
	github.com/stapelberg/rgb2r/cmd/node_exporter \
	github.com/stapelberg/rgb2r/cmd/blackbox_exporter \
	github.com/stapelberg/rgb2r/cmd/ratelimit \
	github.com/stapelberg/rgb2r/cmd/tc \
	github.com/stapelberg/rgb2r/cmd/wg

image:
ifndef DIR
	@echo variable DIR unset
	false
endif
	GOARCH=amd64 gokr-packer \
		-gokrazy_pkgs=github.com/gokrazy/gokrazy/cmd/ntp,github.com/gokrazy/gokrazy/cmd/randomd \
		-kernel_package=github.com/rtr7/kernel \
		-firmware_package=github.com/rtr7/kernel \
		-overwrite_boot=${DIR}/boot.img \
		-overwrite_root=${DIR}/root.img \
		-overwrite_mbr=${DIR}/mbr.img \
		-serial_console=ttyS0,115200n8 \
		-hostname=rgb2router \
		${PKGS}
</code></pre>

<p>After preparing an <code>interfaces.json</code> configuration file and a
<a href="https://github.com/gokrazy/breakglass">breakglass</a> SSH hostkey, I used
<code>rtr7-recover</code> to net-install the image onto the apu2c4. For subsequent updates,
I used <code>rtr7-safe-update</code>.</p>

<p>The Go packages under <code>github.com/stapelberg/rgb2r</code> are wrappers which run
software I installed to the permanent partition mounted at <code>/perm</code>. See
<a href="https://gokrazy.org/prototyping.html">gokrazy: Prototyping</a> for more details.</p>

<h3 id="tunnel-setup">Tunnel setup</h3>

<p>Last year, we used a Foo-over-UDP tunnel after noticing that we didn’t get
enough bandwidth with OpenVPN. This year, after hearing much about it, we
successfully used <a href="https://www.wireguard.com/">WireGuard</a>.</p>

<p>I found WireGuard to be more performant than OpenVPN, and easier to set up than
either OpenVPN or Foo-over-UDP.</p>

<p>The one wrinkle is that its wire protocol is not yet frozen, and its kernel
module is not yet included in Linux.</p>

<h3 id="traffic-shaping">Traffic shaping</h3>

<p>With asymmetric internet connections, such as the 400/20 cable connection we’re
using, it’s necessary to shape traffic such that the upstream is never entirely
saturated, otherwise the TCP ACK packets won’t reach their destination in time
to saturate the downstream.</p>

<p>While the FritzBox might already provide traffic shaping, we wanted to
voluntarily restrict our upstream usage to leave some headroom for my parents.</p>

<pre><code>rgb2router# tc qdisc replace dev uplink0 root tbf \
  rate 16mbit \
  latency 50ms \
  burst 4000
</code></pre>

<p>The specified <code>latency</code> value is a best guess, and the <code>burst</code> value is derived
from the kernel internal timer frequency (<code>CONFIG_HZ</code>) (!), packet size and rate
as per
<a href="https://unix.stackexchange.com/questions/100785/bucket-size-in-tbf">https://unix.stackexchange.com/questions/100785/bucket-size-in-tbf</a>.</p>

<p>Tip: keep in mind to disable shaping temporarily when you’re doing bandwidth
tests ;-).</p>

<h3 id="statistics">Statistics</h3>

<ul>
<li><p>We peaked at 59 active DHCP leases, which is very similar to the “about 60”
last year.</p></li>

<li><p>DNS traffic peaked at about 25 queries/second, while mostly remaining at less
than 5 queries/second.</p></li>

<li><p>We were able to obtain peaks of nearly 200 Mbit/s of download traffic and
transferred over 200 GB of data, twice as much as last year.</p></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[Looking for a new Raspberry Pi image maintainer]]></title>
    <link href="https://michael.stapelberg.ch/posts/2018-06-03-raspi3-looking-for-maintainer/"/>
    <id>https://michael.stapelberg.ch/posts/2018-06-03-raspi3-looking-for-maintainer/</id>
    <published>2018-06-03T08:43:00+02:00</published>
    <updated>2019-02-05T09:42:48+01:00</updated>
    <content type="html"><![CDATA[<p>
  <strong>This is taken care of: Gunnar Wolf has taken on maintenance of the Raspberry Pi image. Thank you!</strong>
</p>

<p>
  (Cross-posting this message I sent to pkg-raspi-maintainers for broader visibility.)
</p>

<p>
  I started building Raspberry Pi images because I thought there should be an easy, official way to install Debian on the Raspberry Pi.
</p>

<p>
  I still believe that, but I’m not actually using Debian on any of my Raspberry Pis anymore¹, so my personal motivation to do any work on the images is gone.
</p>

<p>
  On top of that, I realize that my commitments exceed my spare time capacity, so I need to get rid of responsibilities.
</p>

<p>
  Therefore, <strong>I’m looking for someone to take up maintainership of the Raspberry Pi images</strong>. Numerous people have reached out to me with thank you notes and questions, so I think the user interest is there. Also, I’ll be happy to answer any questions that you might have and that I can easily answer. Please reply here (or in private) if you’re interested.
</p>

<p>
  If I can’t find someone within the next 7 days, I’ll put up an announcement message in the raspi3-image-spec README, wiki page, and my blog posts, stating that the image is unmaintained and looking for a new maintainer.
</p>

<p>
  Thanks for your understanding,
</p>

<p>
  ① just in case you’re curious, I’m now running cross-compiled Go programs directly under a Linux kernel and minimal userland, see <a href="https://gokrazy.org/">https://gokrazy.org/</a>
</p>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[Installing Dell’s Ubuntu image on an XPS 9360]]></title>
    <link href="https://michael.stapelberg.ch/posts/2018-05-07-xps-13-9360-linux/"/>
    <id>https://michael.stapelberg.ch/posts/2018-05-07-xps-13-9360-linux/</id>
    <published>2018-05-07T09:10:00+02:00</published>
    <updated>2018-05-07T09:20:01+02:00</updated>
    <content type="html"><![CDATA[

<p>Warning: if you don’t understand one of the steps, don’t blindly follow them,
but ask a friend for help instead! Be sure to have a known-working backup
before messing with your system.</p>

<h3 id="motivation">Motivation</h3>

<p>I recently got a Dell XPS 13 9360 (2017), which of course I would like to use
with Linux. I figured I’d give Dell’s Ubuntu version a try, as it is the closest
I can get to a supported Linux offering on a modern laptop.</p>

<p>Unfortunately, Dell doesn’t sell the XPS 9360 in its shop anymore (and I don’t
like its successor due to the lack of USB A ports), so I had to resort to buying
a version that comes with Windows.</p>

<p>You can obtain the recovery image
<code>dell-bto-xenial-dino2-mlk-A00-iso-20161021-0.iso</code> from
<a href="http://www.dell.com/support/home/us/en/19/Drivers/OSISO/W764">http://www.dell.com/support/home/us/en/19/Drivers/OSISO/W764</a>, provided you have
the system tag of an XPS 9360 that came with Linux — ask a friend if you
accidentally purchased the Windows version. Tip: the service tag is the BIOS
serial number, which is included in the output of
<a href="https://manpages.debian.org/stretch/lshw/lshw.1.en"><code>lshw(1)</code></a> and similar
tools.</p>

<h3 id="making-the-image-bootable">Making the image bootable</h3>

<p>I don’t understand why this image is not bootable by default. The device it was
generated for never had a CD/DVD drive, so what good is using an ISO 9660 image?</p>

<p>Anyway, to make the image bootable, I formatted a USB thumb drive with a FAT
file system and installed GRUB in such a way that it will loopback-boot into the
ISO image (this is option 2 from <a href="https://askubuntu.com/a/395880">https://askubuntu.com/a/395880</a>):</p>

<pre><code>grub-mkimage -o bootx64.efi -p /efi/boot -O x86_64-efi \
 fat iso9660 part_gpt part_msdos \
 normal boot linux configfile loopback chain \
 efifwsetup efi_gop efi_uga \
 ls search search_label search_fs_uuid search_fs_file \
 gfxterm gfxterm_background gfxterm_menu test all_video loadenv \
 exfat ext2 ntfs btrfs hfsplus udf
cat &gt;grub.cfg &lt;&lt;'EOT'
set timeout=3
set color_highlight=black/light-magenta

menuentry 'Ubuntu ISO' {
        set isofile=&quot;/efi/boot/dell-bto-xenial-dino2-mlk-A00-iso-20161021-0.iso&quot;
        loopback loop $isofile
        linux (loop)/casper/vmlinuz.efi boot=casper iso-scan/filename=$isofile noprompt noeject quiet splash persistent --
        initrd (loop)/casper/initrd.lz
}
EOT

sudo mkfs.vfat /dev/sdc
pmount /dev/sdc
mkdir -p /media/sdc/efi/boot
cp bootx64.efi *.iso grub.cfg /media/sdc/efi/boot
pumount sdc
</code></pre>

<h3 id="making-the-installer-work">Making the installer work</h3>

<p>To get the installer to work, I had to comment out the <code>self.genuine</code> checks in
<code>/usr/lib/ubiquity/plugins/dell-{bootstrap,recovery}.py</code>, then start <code>ubiquity</code>
from the terminal.</p>

<h3 id="switch-to-luks-full-disk-encryption">Switch to LUKS full-disk encryption</h3>

<p>Unfortunately, the recovery installation only offers you to encrypt your
homedir, whereas I would like to encrypt my entire disk. Here are the steps I
took to enable LUKS full-disk encryption.</p>

<p>First, I copied the root file system’s data to my backup storage. Pay attention
to copying the files as root, otherwise setuid and setgid bits might get lost.</p>

<pre><code># mount /dev/mapper/nvme0n1p3 /mnt/root
# rsync -aXx --relative --numeric-ids /mnt/root/ root@storage:xps/
# umount /mnt/root
</code></pre>

<p>Then, I created a new boot partition, encrypted the root partition and re-created the file system:</p>

<pre><code># cat &lt;&lt;'EOT' | sfdisk /dev/nvme0n1
label: gpt
label-id: C64A87D1-CA61-4BF2-81E6-0216EE6BC4C0
device: /dev/nvme0n1
unit: sectors
first-lba: 34
last-lba: 2000409230

/dev/nvme0n1p1 : start=          34, size=      488248, type=C12A7328-F81F-11D2-BA4B-00A0C93EC93B, name=&quot;EFI System Partition&quot;
/dev/nvme0n1p2 : start=      488282, size=     5380681, type=EBD0A0A2-B9E5-4433-87C0-68B6B72699C7, name=&quot;fat32&quot;
/dev/nvme0n1p3 : start=     5869568, size=     2097152, type=0FC63DAF-8483-4772-8E79-3D69D8477DE4
/dev/nvme0n1p4 : start=     7966720, size=  1992442511, type=0FC63DAF-8483-4772-8E79-3D69D8477DE4
EOT
# mkfs.ext2 /dev/nvme0n1p3
# cryptsetup luksFormat /dev/nvme0n1p4
# cryptsetup luksOpen /dev/nvme0n1p4 nvme0n1p3_crypt
# mkfs.ext4 /dev/mapper/nvme0n1p4_crypt
</code></pre>

<p>Next, I restored the data:</p>

<pre><code># mount /dev/mapper/nvme0n1p4_crypt /mnt/root
# mount /dev/nvme0n1p3 /mnt/root/boot
# mkdir /mnt/root/boot/efi
# mount /dev/nvme0n1p1 /mnt/root/boot/efi
# rsync -aXx --numeric-ids storage:xps/ /mnt/root
</code></pre>

<p>And finally, I fixed the boot partition:</p>

<pre><code># mount -o bind /dev /mnt/root/dev
# mount -t sysfs sysfs /mnt/root/sys
# mount -t proc proc /mnt/root/proc
# chroot /mnt/root /bin/bash

# apt install cryptsetup
# echo nvme0n1p4_crypt UUID=$(blkid -o value -s UUID /dev/nvme0n1p4) none luks,discard &gt; /etc/crypttab
# cat &gt;/etc/fstab &lt;&lt;EOT
UUID=$(blkid -o value -s UUID /dev/mapper/nvme0n1p4_crypt) / ext4 errors=remount-ro 0 1
UUID=$(blkid -o value -s UUID /dev/nvme0n1p3) /boot ext2 defaults 0 0
UUID=$(blkid -o value -s UUID /dev/nvme0n1p1) /boot/efi vfat umask=0077 0 1
EOT
# update-initramfs -u
# update-grub
# grub-install

# umount /mnt/root/{proc,sys,dev,boot/efi,boot,}
</code></pre>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[kinX: USB Hub]]></title>
    <link href="https://michael.stapelberg.ch/posts/2018-04-17-kinx-usb-hub/"/>
    <id>https://michael.stapelberg.ch/posts/2018-04-17-kinx-usb-hub/</id>
    <published>2018-04-17T17:49:00+02:00</published>
    <updated>2019-01-26T23:11:13+01:00</updated>
    <content type="html"><![CDATA[

<p>This post is part of a <a href="/posts/2018-04-17-kinx">series of posts about the kinX project</a>.</p>

<h3 id="motivation">Motivation</h3>

<p>The Kinesis Advantage comes with a built-in 2-port USB hub. That hub uses a
proprietary connector to interface with a
<a href="https://en.wikipedia.org/wiki/PS/2_port">PS/2</a> keyboard controller, so it
cannot be used with a USB keyboard controller. As the built-in hub is the
natural place to connect the Logitech unified receiver dongle, not being able to
use the hub is mildly annoying.</p>

<p>The kinX MK66F keyboard controller presently needs two USB cables: one connected
to the USBFS port to supply the PCB with power and receive firmware updates (via
the Teensy bootloader chip), and one connected to the USBHS port for the actual
keyboard device.</p>

<p>Lastly, even if the original built-in USB hub had internal ports (instead of a
PS/2 converter), it only supports USB 1.1, nullifying any latency improvements.</p>

<p>Hence, I decided to build a drop-in replacement USB 2.0 hub with 2 external USB
ports and 2 internal USB ports, using the same proprietary connector as the
original, so that the original keyboard USB cable could be re-used.</p>

<h3 id="design-phase">Design phase</h3>

<p>Unfortunately, I could not find an open hardware USB 2.0 hub design on the
internet, so I started researching various USB hub chips. I quickly discarded
the idea of using USB 3 due to its much stricter requirements.</p>

<p>In the end, I decided to go with the Cypress HX2VL series because of their
superior documentation: I found a detailed data sheet, an evaluation board, the
associated schematics, design checklist/guidelines, and even the evaluation
board’s bill of materials.</p>

<p>This is what the finished build of my design looks like:</p>

<p><img src="/Bilder/kinx-hub.jpg" width="100%"></p>

<h3 id="power">Power</h3>

<p>After completing my first build, I tested a few USB devices with my hub. The
Logitech unified receiver dongle and the
<a href="https://www.yubico.com/start/">YubiKey</a> worked fine. However, my external hard
drive and my USB memory stick did not work. In the syslog, I would see:</p>

<pre><code>kernel: usb 1-14.4.4: rejected 1 configuration due to insufficient available bus power
</code></pre>

<p>This is because the USB specification limits bus-powered hubs to 100mA per
port. While high power usage does not come as a surprise for the external hard
disk, it turns out that even my USB memory stick requires 200mA. This was a
surprise, because that stick works on other, commercial bus-powered USB hubs.</p>

<p>A closer look reveals that all 3 commercial USB hubs I have tested claim to be
self-powered (i.e. using an external power supply), even though they are
not. This way, the kernel’s power limitation is circumvented, and up to 500mA
can be used per port. In practice, the host port only supplies 500mA, so the
user must be careful not to plug in devices which require more than 500mA in
aggregate.</p>

<p>I changed the SELFPWR configuration pin to have my hub claim it was
self-powered, too, and that made all USB devices I tested work fine.</p>

<h3 id="eeprom-programming">EEPROM programming</h3>

<p>When debugging the power issue, I originally thought the Maximum Power setting
in the hub’s USB device descriptor needed to be raised. This turned out to not
be correct: the Maximum Power refers to the power which the hub uses for its own
circuitry, not the power it passes through to connected devices.</p>

<p>Nevertheless, it’s a nice touch to modify the device descriptor to put in a
custom vendor name, product name and serial number: that way, the device shows
up with a recognizable name in your syslog or
<a href="https://manpages.debian.org/stretch/usbutils/lsusb.8"><code>lsusb(8)</code></a> output, and
udev rules can be used to apply settings based on the serial number.</p>

<p>To modify the device descriptor, an <a href="https://en.wikipedia.org/wiki/EEPROM">EEPROM (electrically erasable programmable
read-only memory)</a> needs to be added to
the design, from which the HX2VL will read configuration.</p>

<p>The HX2VL allows field-programming of the connected EEPROM, i.e. writing to it
via the USB hub chip. I found the Windows-only tool hard to set up on a modern
Windows installation, so I wondered whether I could build a simpler to use tool.</p>

<p>Under the covers, the tool merely sends commands with the vendor-specific
request code 14 via USB, specifying an index of the two-byte word to
read/write. This can be replicated in a few lines of Go:</p>

<pre><code>dev, _ := usb.OpenDeviceWithVIDPID(0x04b4, 0x6570)
eepromRequest := 14
wIndex := 0 // [0, 63] for 128 bytes of EEPROM
dev.Control(gousb.RequestTypeVendor|0x80, 
  eepromRequest, 0, wIndex, make([]byte, 2))
</code></pre>

<p>The EEPROM contents are well-described in the <a href="http://www.cypress.com/file/114101/download">HX2VL data
sheet</a>, so the rest is easy.</p>

<p>See <a href="https://github.com/kinx-project/mk66f-blaster">https://github.com/kinx-project/mk66f-blaster</a> for the tool.</p>

<h3 id="lessons-learnt">Lessons learnt</h3>

<ul>
<li><p>If possible, design the PCB in such a way that components you think you don’t
need (e.g. the EEPROM) can optionally be soldered on. This would have saved me
a PCB design/fabrication cycle.</p></li>

<li><p>Get the evaluation board to figure out the configuration you need
(e.g. self-powered vs. bus-powered).</p></li>
</ul>

<h3 id="next-up">Next up</h3>

<p>The <a href="/posts/2018-04-17-kinx-latency-measurement/">last post introduces the processing latency measurement firmware for the
FRDM-K66F development board</a> and
draws a conclusion.</p>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[kinX: keyboard controller with &lt;0.225ms input latency]]></title>
    <link href="https://michael.stapelberg.ch/posts/2018-04-17-kinx-keyboard-controller/"/>
    <id>https://michael.stapelberg.ch/posts/2018-04-17-kinx-keyboard-controller/</id>
    <published>2018-04-17T17:49:00+02:00</published>
    <updated>2019-01-26T23:11:13+01:00</updated>
    <content type="html"><![CDATA[

<p>This post is part of a <a href="/posts/2018-04-17-kinx">series of posts about the kinX project</a>.</p>

<h3 id="background">Background</h3>

<p>10 years ago I got a Kinesis Advantage keyboard. I wrote about the experience of
learning to touch-type using the ergonomic <a href="https://neo-layout.org/">NEO layout</a>
in my (German) post <a href="/posts/2009-01-01-neo_kinesis/">“Neo-Layout auf einer
Kinesis-Tastatur”</a>.</p>

<p>The Kinesis Advantage is still the best keyboard I’ve ever used, and I use one
every day, both at the office and at home.</p>

<p>I had two reasons to start modifying the keyboard:</p>

<ol>
<li><p>I prefer Cherry MX blue key switches over the Cherry MX brown key switches
the Kinesis comes with. Nowadays, you can get a Kinesis with Cherry MX red
key switches, which felt okay in a quick test.</p></li>

<li><p>The original keyboard controller has (had?) a bug where modifier keys such as
Shift would get stuck at least once a week: you would press Shift, press A,
release A, release Shift, press A and see AA instead of Aa.</p></li>
</ol>

<p>I solved issue ① with the help of the excellent Kinesis technical support, who
sold me unpopulated PCBs so that I could solder on my own key switches.</p>

<p>Issue ② was what lead to my first own keyboard controller build, which I
documented in <a href="/posts/2013-03-21-kinesis_custom_controller/">“Hacking your own Kinesis keyboard
controller”</a> (2013).</p>

<p>Then, the topic of input latency popped into my filter bubble, with excellent
 posts such as <a href="https://pavelfatin.com/typing-with-pleasure/">Pavel Fatin’s “Typing with
pleasure”</a>. I started wondering
what input latency I was facing, and whether/how I could reduce it.</p>

<p>Given that I was using a custom keyboard controller, it was up to me to answer
that question. After trying to understand and modify the firmware I had been
using for the last 4 years, I realized that I first needed to learn much more
about how keyboards work.</p>

<p>I firmly believe that creating a good environment is vital for development,
especially for intrinsically-motivated side projects like this one. Hence, I set
the project aside until a colleague gifted me his old Kinesis which had
intermittent issues. I removed the electronics and started using that keyboard
as my development keyboard.</p>

<h3 id="sources-of-input-latency">Sources of input latency</h3>

<p>A keyboard controller has 3 major tasks:</p>

<ul>
<li><p><strong>matrix scan</strong>: to avoid physically connecting every single key switch
directly to a microcontroller (requiring a large number of GPIO pins), most
keyboards use a matrix. See <a href="http://blog.komar.be/how-to-make-a-keyboard-the-matrix/">“How to make a keyboard — the
matrix”</a> for a good
explanation.</p></li>

<li><p><strong>debouncing</strong>: when pressing a key switch, it doesn’t cleanly change from a
low voltage level to a high voltage level (or vice-versa). Instead, it
bounces: the voltage level rapidly oscillates until it eventually reaches a
stable steady state. Because one key press shouldn’t result in a whole bunch
of characters, keyboard controllers need to debounce the key press.</p></li>

<li><p><strong>USB</strong>: nowadays, keyboards use USB (for example to be compatible with
laptops, which generally don’t have PS/2 ports), so the keyboard’s state needs
to be communicated to the computer via USB.</p></li>
</ul>

<p>Here’s an illustration of the timing of a key press being handled by a naive
keyboard controller implementation:</p>

<p><img src="/Bilder/kinx-input-latency-sources.svg"></p>

<p>In the worst case, a key press happens just after a keyboard matrix scan. The
first source of latency is the time it takes until the next keyboard matrix scan
happens.</p>

<p>Depending on the implementation, the key press now sits in a data structure,
waiting for the debounce time to pass.</p>

<p>Finally, once the key press was successfully debounced, the device must wait
until the USB host polls it before it can send the HID report.</p>

<p>Unless the matrix scan interval is coupled to the USB poll interval, the delays
are additive, and the debounce time is usually constant: in the best case, a key
press happens just before a matrix scan (0ms) and gets debounced (say, 5ms) just
before a USB poll (0ms).</p>

<h3 id="teensy-3-6-controller-for-learning">Teensy 3.6 controller (for learning)</h3>

<p>My old keyboard controller used the
<a href="https://www.pjrc.com/teensy/index.html">Teensy++</a>, which is fairly dated at
this point. I decided a good start of the project would be to upgrade to the
current Teensy 3.6, cleaning up the schematics on the way.</p>

<p><img src="/Bilder/kinx-teensy36.jpg" width="100%"></p>

<p>To ensure I understand all involved parts, I implemented a bare-metal firmware
almost from scratch: I cobbled together the required startup code, USB stack
and, most importantly, key matrix scanning code.</p>

<p>In my firmware, the Teensy 3.6 runs at 180 MHz (compared to the Teensy++’s 16
MHz) and scans the keyboard matrix in a busy loop (as opposed to on USB
poll). Measurements confirmed a matrix scan time of only 100μs (0.1ms).</p>

<p>I implemented debouncing the way it is described in <a href="https://summivox.wordpress.com/2016/06/03/keyboard-matrix-scanning-and-debouncing/">Yin Zhong’s “Keyboard
Matrix Scanning and
Debouncing”</a>:
by registering a key press/release on the rising/falling edge and applying the
debounce time afterwards, effectively eliminating debounce latency.</p>

<p>Note that while the Cherry MX datasheet specifies a debounce time of 5ms, I
found it necessary to increase the time to 10ms to prevent bouncing in some of
my key switches, which are already a few years old.</p>

<p>I set the USB device descriptor’s poll interval to 1, meaning poll every 1 USB
micro frame, which is 1ms long with USB 1.x (Full Speed).</p>

<p>This leaves us at an input latency within [0ms, 1.1ms]:</p>

<ul>
<li>≤ 0.1ms scan latency</li>
<li>0ms debounce latency</li>
<li>≤ 1ms USB poll latency</li>
</ul>

<p>Can we reduce the input latency even further? The biggest factor is the USB poll
interval.</p>

<h3 id="usb-high-speed">USB High Speed</h3>

<p>With USB 2.0 High Speed, the micro frame duration is reduced to 125μs
(0.125ms). The NXP MK66F micro controller in the Teensy 3.6 has two USB ports:</p>

<ol>
<li>the Full Speed-only USBFS port, which is used by the Teensy 3.6</li>
<li>the High Speed-capable USBHS port, which the Teensy optionally uses for host
mode, with experimental software support (at the time of writing)</li>
</ol>

<p><img src="/Bilder/kinx-usbhs-breakout.jpg" width="100%"></p>

<p>While the software support was a road block which could conceivably be solved, I
also faced a mechanical problem: the available space in the Kinesis keyboard and
the position of the USB High Speed port pins on the Teensy 3.6 unfortunately
prevented installing any sort of breakout board to actually use the port.</p>

<p>I decided to move from the Teensy 3.6 to my own design with the same
microcontroller.</p>

<h3 id="mk66f-keyboard-controller">MK66F keyboard controller</h3>

<p><img src="/Bilder/kinx-mk66f.jpg" width="100%"></p>

<p>To make development pleasant, I connected a USB-to-serial adapter (to UART0) and
a “rebootor” (to PROGHEAD): another Teensy with a special firmware to trigger
programming mode. This way, I could set my editor’s <code>compile-command</code> to <code>make
&amp;&amp; teensy_loader_cli -r …</code>, compiling the code, uploading and booting into the
resulting firmware with a single keyboard shortcut.</p>

<p>I based the firmware for this controller on NXP’s SDK examples, to ensure I get
a well-tested and maintained USB stack for the USBHS port. I did some
measurements to confirm the stack does not add measurable extra latency, so I
did not see any value in me maintaining a custom USB stack.</p>

<p>The firmware can be found at <a href="https://github.com/kinx-project/mk66f-fw">https://github.com/kinx-project/mk66f-fw</a></p>

<p>The hardware can be found at <a href="https://github.com/kinx-project/mk66f-hw">https://github.com/kinx-project/mk66f-hw</a></p>

<p>Using USB 2.0 High Speed leaves us at an input latency within [0ms, 0.225ms]:</p>

<ul>
<li>≤ 0.1ms scan latency</li>
<li>0ms debounce latency</li>
<li>≤ 0.125ms USB poll latency</li>
</ul>

<h3 id="lessons-learnt">Lessons learnt</h3>

<ul>
<li><p>In the future, I will base custom designs on the vendor’s development board
(instead of on the Teensy). This way, the vendor-provided code could be used
without any modifications.</p></li>

<li><p>While the Teensy bootloader means getting started with the microcontroller
just requires a USB port, using a JTAG connector for development would be more
powerful: not only does it replace the combination of Teensy bootloader,
serial and rebootor, but it also supports debugging with gdb.</p></li>
</ul>

<h3 id="next-up">Next up</h3>

<p>The <a href="/posts/2018-04-17-kinx-usb-hub/">second post motivates and describes building a drop-in replacement USB
hub</a> for the Kinesis Advantage keyboard.</p>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[kinX: latency measurement]]></title>
    <link href="https://michael.stapelberg.ch/posts/2018-04-17-kinx-latency-measurement/"/>
    <id>https://michael.stapelberg.ch/posts/2018-04-17-kinx-latency-measurement/</id>
    <published>2018-04-17T17:49:00+02:00</published>
    <updated>2019-01-26T23:11:13+01:00</updated>
    <content type="html"><![CDATA[

<p>This post is part of a <a href="/posts/2018-04-17-kinx">series of posts about the kinX project</a>.</p>

<h3 id="latency-measurement">Latency measurement</h3>

<p>End-to-end latency consists of 3 parts:</p>

<ol>
<li>input latency (keyboard)</li>
<li>processing latency (computer)</li>
<li>output latency (monitor)</li>
</ol>

<p>During the development of the kinX keyboard controller, I realized that
measuring processing latency was quite simple with my hardware: I could start a
timer when sending a key press HID report to the computer and measure the
elapsed time when I would receive a reply from the computer.</p>

<p>The key to send is the Caps Lock key, because unlike other keys it results in a
reply: a HID report telling the keyboard to turn the Caps Lock LED on.</p>

<p><img src="/Bilder/kinx-latency-measurement-device.svg"></p>

<h3 id="measurement-device">Measurement device</h3>

<p>To make this measurement technique accessible to as many people as possible, I
decided to pull it out of my kinX keyboard controller and instead build it using
the FRDM-K66F evaluation board, which uses the same microcontroller.</p>

<p>The FRDM-K66F can be bought for about 60 USD at big electronics shops, e.g. Digi-Key.</p>

<p>Find the firmware at <a href="https://github.com/kinx-project/measure-fw">https://github.com/kinx-project/measure-fw</a></p>

<h3 id="baseline">Baseline</h3>

<p>To determine the lowest processing latency one can possibly get for userspace
applications on a Linux system, I wrote a small program which uses Linux’s evdev
API to receive key presses and react to a Caps Lock keypress as quickly as it
can by turning the Caps Lock LED on.</p>

<p>Find the program at <a href="https://github.com/kinx-project/measure-evdev">https://github.com/kinx-project/measure-evdev</a></p>

<p>The following layers are exercised when measuring this program:</p>

<ul>
<li>USB host controller</li>
<li>Linux kernel (USB and input subsystems)</li>
<li>input event API (evdev)</li>
</ul>

<p>Notably, graphical interfaces such as X11 or Wayland are excluded.</p>

<p>The measurements can be verified using Wireshark’s usbmon capturing, which
provides a view of the USB bus from the computer’s perspective, excluding USB
poll latency and USB transaction time.</p>

<p>Using Ubuntu 17.10, I measured a processing latency of 152 μs on average.</p>

<h3 id="emacs">Emacs</h3>

<p>Now let’s see whether my current editor of choice adds significant latency.</p>

<p>Using a few lines of Emacs Lisp, I instructed Emacs to turn on the Caps Lock LED
whenever a key is inserted into the current buffer. In combination with
remapping the Caps Lock key to any other key (e.g. “a”), this allows us to
measure Emacs’s processing latency.</p>

<p>On the same Ubuntu 17.10 installation used above, Emacs 25.2.2 adds on average
278 μs to the baseline processing latency.</p>

<p>Find the code at <a href="https://github.com/kinx-project/measure-emacs">https://github.com/kinx-project/measure-emacs</a></p>

<h3 id="end-to-end-latency">End-to-end latency</h3>

<p>With the kinX keyboard controller, we can achieve the following end-to-end latency:</p>

<table>
<thead>
<tr>
<th>contributor</th>
<th>latency</th>
</tr>
</thead>

<tbody>
<tr>
<td>Matrix scan</td>
<td>≈ 100 μs</td>
</tr>

<tr>
<td>USB poll</td>
<td>≈ 125 μs</td>
</tr>

<tr>
<td>Linux</td>
<td>≈ 152 μs</td>
</tr>

<tr>
<td>Emacs</td>
<td>≈ 278 μs</td>
</tr>
</tbody>
</table>

<p><br>This sums up to ≈ 655 μs on average. On top of that, we have output latency
within [0, 16ms] due to the 60 Hz refresh rate of our monitors.</p>

<p>Note that using a compositor adds one frame of output latency.</p>

<h3 id="input-latency-perception">Input latency perception</h3>

<p>A natural question to ask is how well humans can perceive input latency. After
all, keyboards have been manufactured for many years, and if input latency was
really that important, surely manufacturers would have picked up on this fact by
now?</p>

<p>I ran a little unscientific experiment in the hope to further my understanding
of this question at the most recent Chaos Communication Congress in Leipzig.</p>

<p>In the experiment, I let 17 people play a game on a specially prepared
keyboard. In each round, the game reconfigures the keyboard to either have
additional input latency or not, decided at random. The player can then type a
few keys and make a decision. If the player can correctly indicate whether
additional input latency was present in more than 50% of the cases, the player
is said to be able to distinguish latency at that level. On each level, the game
decreases the additional input latency: it starts with 100ms, then 75ms, then
50ms, etc.</p>

<p>The most sensitive player reliably recognized an additional 15ms of input
latency.</p>

<p>Some players could not distinguish 75ms of additional input latency.</p>

<p>Every player could distinguish 100ms of additional input latency.</p>

<p>My take-away is that many people cannot perceive slight differences in input
latency at all, explaining why keyboard manufacturers don’t optimize for low
latency.</p>

<p>Reducing input latency still seems worthwhile to me: even if the reduction
happens under the threshold at which you can perceive differences in input
latency, it buys you more leeway in the entire stack. In other words, you might
now be able to turn on an expensive editor feature which previously slowed down
typing too much.</p>

<h3 id="conclusion">Conclusion</h3>

<p>When I started looking into input latency, my keyboard had dozens of
milliseconds of latency. I found an easy win in the old firmware, then hit a
wall, started the kinX project and eventually ended up with a keyboard with just
0.225ms input latency.</p>

<p>Even if I had not reduced the input latency of my keyboard at all, I feel that
this project was a valuable learning experience: I now know a lot more about PCB
design, ARM microcontrollers, USB, HID, etc.</p>

<p>Typing on a self-built keyboard feels good: be it because of the warm fuzzy
feeling of enjoying the fruits of your labor, or whether the input latency
indeed is lower, I’m happy with the result either way.</p>

<p>Lastly, I can now decidedly claim that the processing latency of modern
computers is perfectly fine (remember our 152 μs + 278 μs measurement for
Linux + Emacs), and as long as you pick decent peripherals, your end-to-end
latency will be fine, too.</p>

<h3 id="what-s-next">What’s next?</h3>

<p>By far the biggest factor in the end-to-end latency is the monitor’s refresh
rate, so getting a monitor with a high refresh rate and no additional processing
latency would be the next step in reducing the end-to-end latency.</p>

<p>As far as the keyboard goes, the matrix scan could be eliminated by wiring up
each individual key to a microcontroller with enough GPIO pins. The USB poll
delay could be eliminated by switching to USB 3, but I don’t know of any
microcontrollers which have USB 3 built-in yet. Both of these improvements are
likely not worth the effort.</p>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[kinX: overview]]></title>
    <link href="https://michael.stapelberg.ch/posts/2018-04-17-kinx/"/>
    <id>https://michael.stapelberg.ch/posts/2018-04-17-kinx/</id>
    <published>2018-04-17T17:49:00+02:00</published>
    <updated>2019-01-26T23:11:13+01:00</updated>
    <content type="html"><![CDATA[<p>The kinX project is described in a series of blog posts:</p>

<ul>
<li><p>While not strictly a part of this series, <a href="/posts/2013-03-21-kinesis_custom_controller/">“Hacking your own Kinesis keyboard
controller”</a> describes the first
controller I built in 2013 (maybe interesting for context).</p></li>

<li><p>The <a href="/posts/2018-04-17-kinx-keyboard-controller/">first post introduces the kinX, a keyboard
controller</a> with merely 0.2ms of
input latency (including USB).</p></li>

<li><p>The <a href="/posts/2018-04-17-kinx-usb-hub/">second post motivates and describes building a drop-in replacement USB
hub</a> for the Kinesis Advantage keyboard.</p></li>

<li><p>The <a href="/posts/2018-04-17-kinx-latency-measurement/">last post introduces the processing latency measurement firmware for the
FRDM-K66F development board</a> and
draws a conclusion.</p></li>
</ul>

<p>You can find the project’s artifacts at <a href="https://github.com/kinx-project">https://github.com/kinx-project</a>.</p>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[sbuild-debian-developer-setup(1)]]></title>
    <link href="https://michael.stapelberg.ch/posts/2018-03-19-sbuild-debian-developer-setup/"/>
    <id>https://michael.stapelberg.ch/posts/2018-03-19-sbuild-debian-developer-setup/</id>
    <published>2018-03-19T08:00:00+01:00</published>
    <updated>2019-02-04T19:11:20+01:00</updated>
    <content type="html"><![CDATA[<p>
  I have heard a number of times that sbuild is too hard to get started with,
  and hence people don’t use it.
</p>

<p>
  To reduce hurdles from using/contributing to Debian, I wanted to make sbuild
  easier to set up.
</p>

<p>
  sbuild ≥ 0.74.0 provides a Debian package
  called <a href="https://packages.debian.org/sid/sbuild-debian-developer-setup">sbuild-debian-developer-setup</a>. Once
  installed, run
  the <a href="https://manpages.debian.org/unstable/sbuild/sbuild-debian-developer-setup.1">sbuild-debian-developer-setup(1)</a>
  command to create a chroot suitable for building packages for Debian unstable.
</p>

<p>
  On a system without any sbuild/schroot bits installed, a transcript of the
  full setup looks like this:
</p>

<pre>
% sudo apt install -t unstable sbuild-debian-developer-setup
Reading package lists... Done
Building dependency tree
Reading state information... Done
The following additional packages will be installed:
  libsbuild-perl sbuild schroot
Suggested packages:
  deborphan btrfs-tools aufs-tools | unionfs-fuse qemu-user-static
Recommended packages:
  exim4 | mail-transport-agent autopkgtest
The following NEW packages will be installed:
  libsbuild-perl sbuild sbuild-debian-developer-setup schroot
0 upgraded, 4 newly installed, 0 to remove and 1454 not upgraded.
Need to get 1.106 kB of archives.
After this operation, 3.556 kB of additional disk space will be used.
Do you want to continue? [Y/n]
Get:1 http://localhost:3142/deb.debian.org/debian unstable/main amd64 libsbuild-perl all 0.74.0-1 [129 kB]
Get:2 http://localhost:3142/deb.debian.org/debian unstable/main amd64 sbuild all 0.74.0-1 [142 kB]
Get:3 http://localhost:3142/deb.debian.org/debian testing/main amd64 schroot amd64 1.6.10-4 [772 kB]
Get:4 http://localhost:3142/deb.debian.org/debian unstable/main amd64 sbuild-debian-developer-setup all 0.74.0-1 [62,6 kB]
Fetched 1.106 kB in 0s (5.036 kB/s)
Selecting previously unselected package libsbuild-perl.
(Reading database ... 276684 files and directories currently installed.)
Preparing to unpack .../libsbuild-perl_0.74.0-1_all.deb ...
Unpacking libsbuild-perl (0.74.0-1) ...
Selecting previously unselected package sbuild.
Preparing to unpack .../sbuild_0.74.0-1_all.deb ...
Unpacking sbuild (0.74.0-1) ...
Selecting previously unselected package schroot.
Preparing to unpack .../schroot_1.6.10-4_amd64.deb ...
Unpacking schroot (1.6.10-4) ...
Selecting previously unselected package sbuild-debian-developer-setup.
Preparing to unpack .../sbuild-debian-developer-setup_0.74.0-1_all.deb ...
Unpacking sbuild-debian-developer-setup (0.74.0-1) ...
Processing triggers for systemd (236-1) ...
Setting up schroot (1.6.10-4) ...
Created symlink /etc/systemd/system/multi-user.target.wants/schroot.service → /lib/systemd/system/schroot.service.
Setting up libsbuild-perl (0.74.0-1) ...
Processing triggers for man-db (2.7.6.1-2) ...
Setting up sbuild (0.74.0-1) ...
Setting up sbuild-debian-developer-setup (0.74.0-1) ...
Processing triggers for systemd (236-1) ...

% sudo sbuild-debian-developer-setup
The user `michael' is already a member of `sbuild'.
I: SUITE: unstable
I: TARGET: /srv/chroot/unstable-amd64-sbuild
I: MIRROR: http://localhost:3142/deb.debian.org/debian
I: Running debootstrap --arch=amd64 --variant=buildd --verbose --include=fakeroot,build-essential,eatmydata --components=main --resolve-deps unstable /srv/chroot/unstable-amd64-sbuild http://localhost:3142/deb.debian.org/debian
I: Retrieving InRelease 
I: Checking Release signature
I: Valid Release signature (key id 126C0D24BD8A2942CC7DF8AC7638D0442B90D010)
I: Retrieving Packages 
I: Validating Packages 
I: Found packages in base already in required: apt 
I: Resolving dependencies of required packages...
[…]
I: Successfully set up unstable chroot.
I: Run "sbuild-adduser" to add new sbuild users.
ln -s /usr/share/doc/sbuild/examples/sbuild-update-all /etc/cron.daily/sbuild-debian-developer-setup-update-all
Now run `newgrp sbuild', or log out and log in again.

% newgrp sbuild

% sbuild -d unstable hello
sbuild (Debian sbuild) 0.74.0 (14 Mar 2018) on x1

+==============================================================================+
| hello (amd64)                                Mon, 19 Mar 2018 07:46:14 +0000 |
+==============================================================================+

Package: hello
Distribution: unstable
Machine Architecture: amd64
Host Architecture: amd64
Build Architecture: amd64
Build Type: binary
[…]
</pre>

<p>
  I hope you’ll find this useful.
</p>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[cpu(1) with Linux]]></title>
    <link href="https://michael.stapelberg.ch/posts/2018-03-13-cpu/"/>
    <id>https://michael.stapelberg.ch/posts/2018-03-13-cpu/</id>
    <published>2018-03-13T09:35:00+01:00</published>
    <updated>2018-06-23T15:07:33+02:00</updated>
    <content type="html"><![CDATA[

<h3 id="motivation">motivation</h3>

<p>To run the tests of my i3 Go package, I use the following command:</p>

<pre><code>go test -v go.i3wm.org/...
</code></pre>

<p>To run the tests of my i3 Go package on a different architecture, the only thing
I should need to change is to declare the architecture by setting
<code>GOARCH=arm64</code>:</p>

<pre><code>GOARCH=arm64 go test -v go.i3wm.org/...
</code></pre>

<p>“Easy!”, I hear you exclaim: “Just <code>apt install qemu</code>, and you can transparently
emulate architectures”. But what if I want to run my tests on a native machine,
such as the various <a href="https://db.debian.org/machines.cgi?sortby=purpose&amp;sortorder=dsc">Debian porter
boxes</a>? Down
the rabbit hole we go…</p>

<h3 id="cpu-1">cpu(1)</h3>

<p>On Plan 9, the <a href="http://man.cat-v.org/plan_9/1/cpu">cpu(1)</a> command allows
transparently using the CPU of dedicated compute servers. This has fascinated me
for a long time, so I tried to replicate the functionality in Linux.</p>

<h3 id="reverse-sshfs">reverse sshfs</h3>

<p>One of the key insights this project is built on is that
<a href="https://manpages.debian.org/stretch/sshfs/sshfs.1"><code>sshfs(1)</code></a> can be used over
an already-authenticated channel, so you don’t need to do awkward reverse
port-forwardings or even allow the remote machine SSH access to your local
machine.</p>

<p>I learnt this trick from the 2014 <a href="https://blog.dhampir.no/content/reverse-sshfs-mounts-fs-push">boltblog post “Reverse SSHFS mounts (fs
push)”</a>.</p>

<p>The post uses <a href="https://manpages.debian.org/stretch/vde2/dpipe.1"><code>dpipe(1)</code></a>’s
bidirectional wiring of stdin/stdout (as opposed to a unidirectional wiring like
in UNIX pipes).</p>

<p>Instead of clumsily running <code>dpipe</code> in a separate window, I encapsulated the
necessary steps in a little Go program I call <code>cpu</code>. The reverse sshfs principle
looks like this in Go:</p>

<pre><code>sftp := exec.Command(&quot;/usr/lib/openssh/sftp-server&quot;)
stdin, _ := sftp.StdinPipe()
stdout, _ := sftp.StdoutPipe()
session.Stdin = stdout
session.Stdout = stdin
sftp.Stderr = os.Stderr
session.Stderr = os.Stderr
const (
	host = &quot;&quot;
	src  = &quot;/&quot;
	mnt  = &quot;/mnt&quot;
)
session.Start(fmt.Sprintf(&quot;sshfs %s:%s %s -o slave&quot;, host, src, mnt))
sftp.Start()
</code></pre>

<p>Here’s how the tool looks in action:</p>

<script src="https://asciinema.org/a/Q1BWLcdtIMOE5SCHOzu1eqcOE.js" id="asciicast-Q1BWLcdtIMOE5SCHOzu1eqcOE" async></script>

<h3 id="binfmt-misc">binfmt_misc</h3>

<p>Now that we have a tool which will make our local file system available on the
remote machine, let’s integrate it into our <code>go test</code> invocation.</p>

<p>While we don’t want to modify the <code>go</code> tool, we can easily teach our kernel how
to run aarch64 ELF binaries using
<a href="https://www.kernel.org/doc/html/v4.14/admin-guide/binfmt-misc.html">binfmt_misc</a>.</p>

<p>I modified the existing <code>/var/lib/binfmts/qemu-aarch64</code>’s interpreter field to
point to <code>/home/michael/go/bin/porterbox-aarch64</code>, followed by <code>update-binfmts
--enable qemu-aarch64</code> to have the kernel pick up the changes.</p>

<p><code>porterbox-aarch64</code> is a wrapper invoking <code>cpu</code> like so:</p>

<pre><code>cpu \
  -host=rpi3 \
  unshare \
    --user \
    --map-root-user \
    --mount-proc \
    --pid \
    --fork \
    /bindmount.sh \
      \$PWD \
      $PWD \
      $@
</code></pre>

<p>Because it’s subtle:</p>

<ul>
<li><code>\$PWD</code> refers to the directory in which the reverse sshfs was mounted by <code>cpu</code>.</li>
<li><code>$PWD</code> refers to the working directory in which <code>porterbox-aarch64</code> was called.</li>
<li><code>$@</code> refers to the original command with which <code>porterbox-aarch64</code> was called.</li>
</ul>

<h3 id="bindmount">bindmount</h3>

<p>bindmount is a small shell script preparing the bind mounts:</p>

<pre><code>#!/bin/sh

set -e

remote=&quot;$1&quot;
shift
wd=&quot;$1&quot;
shift

# Ensure the executable (usually within /tmp) is available:
exedir=$(dirname &quot;$1&quot;)
mkdir -p &quot;$exedir&quot;
mount --rbind &quot;$remote$exedir&quot; &quot;$exedir&quot;

# Ensure /home is available:
mount --rbind &quot;$remote/home&quot; /home

cd &quot;$wd&quot;
&quot;$@&quot;
</code></pre>

<h3 id="demo">demo</h3>

<p>This is what all of the above looks like in action:</p>

<script src="https://asciinema.org/a/Mjb66iHIbBfGuK5lEMnLt0UzS.js" id="asciicast-Mjb66iHIbBfGuK5lEMnLt0UzS" async></script>

<h3 id="layers">layers</h3>

<p>Putting all of the above puzzle pieces together, we end up with the following
picture:</p>

<pre><code>go test
├ compile test program for GOARCH=arm64
└ exec test program (on host)
  └ binfmt_misc
    └ run porterbox-aarch64
      └ cpu -host=rpi3
        ├ reverse sshfs
        └ bindmount.sh
          └ unshare --user
            ├ bind /home, /tmp
            └ run test program (on target)
</code></pre>

<h3 id="requirements">requirements</h3>

<p>On the remote host, the following requirements need to be fulfilled:</p>

<ul>
<li><code>apt install sshfs</code>, which also activates the FUSE kernel module</li>
<li><code>sysctl -w kernel.unprivileged_userns_clone=1</code></li>
</ul>

<p>If the tests require any additional dependencies (the tests in question require
<code>Xvfb</code> and <code>i3</code>), those need to be installed as well.</p>

<p>On Debian porter boxes, you can install the dependencies in an <a href="https://dsa.debian.org/doc/schroot/"><code>schroot</code>
session</a>. Note that I wasn’t able to test
this yet, as porter boxes lacked all requirements at the time of writing.</p>

<p>Unfortunately, <a href="https://wiki.debian.org/Multiarch">Debian’s Multi-Arch</a> does not
yet include binaries. Otherwise, one might use it to help out with the
dependencies: one could overlay the local <code>/usr/bin/aarch64-linux-gnu/</code> on the
remote <code>/usr/bin</code>.</p>

<h3 id="conclusion">conclusion</h3>

<p>On first glance, this approach works as expected. Time will tell whether it’s
useful in practice or just an interesting one-off exploration.</p>

<p>From a design perspective, there are a few open questions:</p>

<ul>
<li>Making available only <code>/home</code> might not be sufficient. But making available
<code>/</code> doesn’t work because <code>sshfs</code> does not support device nodes such as
<code>/dev/null</code>.</li>
<li>Is there a way to implement this without unprivileged user namespaces (which
are disabled by default on Linux)? Essentially, I think I’m asking for <a href="https://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs#Union_directories_and_namespaces">Plan
9’s union directories and
namespaces</a>.</li>
<li>In similar spirit, can binfmt_misc be used per-process?</li>
</ul>

<p>Regardless, if this setup stands the test of time, I’ll polish and publish the
tools.</p>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[dput usability changes]]></title>
    <link href="https://michael.stapelberg.ch/posts/2018-03-10-dput-usability/"/>
    <id>https://michael.stapelberg.ch/posts/2018-03-10-dput-usability/</id>
    <published>2018-03-10T10:00:00+01:00</published>
    <updated>2019-02-04T19:11:20+01:00</updated>
    <content type="html"><![CDATA[<p>
  dput-ng ≥ 1.16 contains two usability changes which make uploading easier:
</p>

<ol>
  <li>
    When no arguments are specified, dput-ng auto-selects the most recent .changes file (with confirmation).
  </li>
  <li>
    Instead of erroring out when detecting an unsigned .changes file, <a href="https://manpages.debian.org/stretch/devscripts/debsign.1">debsign(1)</a> is invoked to sign the .changes file before proceeding.
  </li>
</ol>

<p>
  With these changes, after building a package, you just need to
  type <code>dput</code> (in the correct directory of course) to sign and upload
  it.
</p>
]]></content>
  </entry>
</feed>
