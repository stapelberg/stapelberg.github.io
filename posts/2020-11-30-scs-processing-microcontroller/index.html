<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Fixing the Nuki Opener smart intercom IOT device (on the BTicino SCS bus intercom system) (2020) - Michael Stapelberg</title>

  <meta property="og:site_name" content="Michael Stapelberg">
  <meta property="og:title" content="Fixing the Nuki Opener smart intercom IOT device (on the BTicino SCS bus intercom system)">
  <meta property="og:description" content="This post is the second article in a series of blog posts about the Nuki Opener on the SCS bus intercom, see the Series Overview.
I recently bought a Nuki Opener, which “turns your existing intercom into a smart door opener”.">
  
  
  
  
  <meta property="og:image" content="https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-11-28-nuki-opener-filtered-featured_hu46bb619362d02271ee9d454f3a246020_1421516_200x200_fit_q75_box.jpg">
  
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
  <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="/favicon-48x48.png" sizes="48x48">
  <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
  <meta name="description" content="This post is the second article in a series of blog posts about the Nuki Opener on the SCS bus intercom, see the Series Overview.
I recently bought a Nuki Opener, which “turns your existing intercom into a smart door opener”.">
  <link rel="canonical" href="https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/">
  <meta name="author" content="Michael Stapelberg">
  <style type="text/css">
    @font-face {
	font-family: 'Roboto Mono';
	src: url('/font/subset-RobotoMono-Regular.eot');
	src: local('Roboto Mono Regular'), local('RobotoMono-Regular'),
        url('/font/subset-RobotoMono-Regular.eot?#iefix') format('embedded-opentype'),
        url('/font/subset-RobotoMono-Regular.woff2') format('woff2'),
        url('/font/subset-RobotoMono-Regular.woff') format('woff'),
        url('/font/subset-RobotoMono-Regular.ttf') format('truetype');
	font-weight: normal;
	font-style: normal;
	font-display: swap;
    }

    @font-face {
	font-family: 'Roboto';
	src: url('/font/subset-Roboto-Bold.eot');
	src: local('Roboto Bold'), local('Roboto-Bold'),
        url('/font/subset-Roboto-Bold.eot?#iefix') format('embedded-opentype'),
        url('/font/subset-Roboto-Bold.woff2') format('woff2'),
        url('/font/subset-Roboto-Bold.woff') format('woff'),
        url('/font/subset-Roboto-Bold.ttf') format('truetype');
	font-weight: bold;
	font-style: normal;
	font-display: swap;
    }

    @font-face {
	font-family: 'Roboto';
	src: url('/font/subset-Roboto-Regular.eot');
	src: local('Roboto'), local('Roboto-Regular'),
        url('/font/subset-Roboto-Regular.eot?#iefix') format('embedded-opentype'),
        url('/font/subset-Roboto-Regular.woff2') format('woff2'),
        url('/font/subset-Roboto-Regular.woff') format('woff'),
        url('/font/subset-Roboto-Regular.ttf') format('truetype');
	font-weight: normal;
	font-style: normal;
	font-display: swap;
    }

    @font-face {
	font-family: 'Lato';
	src: url('/font/subset-Lato-Bold.eot');
	src: local('Lato Bold'), local('Lato-Bold'),
        url('/font/subset-Lato-Bold.eot?#iefix') format('embedded-opentype'),
        url('/font/subset-Lato-Bold.woff2') format('woff2'),
        url('/font/subset-Lato-Bold.woff') format('woff'),
        url('/font/subset-Lato-Bold.ttf') format('truetype');
	font-weight: bold;
	font-style: normal;
	font-display: swap;
    }

    body, td, th {
	font-family: 'Roboto';
	font-size: 16px;
	line-height: 150%;
	color: #000;
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
	font-family: 'Lato';
	font-weight: bold;
	font-variant-ligatures: none;
	color: #000;
    }
  </style>

  
  <link rel="preload" href="/font/subset-Lato-Bold.woff2" as="font" type="font/woff2" crossorigin>
  <link rel="preload" href="/font/subset-Roboto-Regular.woff2" as="font" type="font/woff2" crossorigin>
  
  <link rel="stylesheet" href="/1.min.css" type="text/css">
  <link rel="alternate" href="/feed.xml" type="application/atom+xml" title="ATOM feed">
</head>
<body>



<header id="ms_navbar">
  <a href="/">
<img
    src="/logo1x.jpg"
    srcset="/logo2x.jpg 2x, /logo3x.jpg 3x"
    width="42"
    height="52"
    alt="profile picture"
    title="profile picture">
</a>
  <div>
    <a href="/"><h1>Michael Stapelberg</h1></a>
    <nav id="ms_desktopnav">
      <ul>
	
    <li><a href="/" >About</a></li>
    <li><a href="/posts/" class="active">Blog</a></li>
    <li><a href="/talks/" >Talks</a></li>
    <li><a href="/series/" >Series</a></li>

      </ul>
    </nav>
  </div>

  <div id="ms_burger_open">
    <label for="ms_burger"><svg viewBox="0 0 100 80" width="24" height="24">
	<rect width="100" height="17" rx="8" fill="white"></rect>
	<rect y="30" width="100" height="17" rx="8" fill="white"></rect>
	<rect y="60" width="100" height="17" rx="8" fill="white"></rect>
    </svg></label>
  </div>

  <input type="checkbox" id="ms_burger">

  <nav id="ms_navdrawer">
    <div id="ms_navdrawer_top">
      <div id="ms_navdrawer_search">
	<a href="/">
<img
    src="/logo1x.jpg"
    srcset="/logo2x.jpg 2x, /logo3x.jpg 3x"
    width="42"
    height="52"
    alt="profile picture"
    title="profile picture">

	<h1>Michael Stapelberg</h1></a>
      </div>
      <div id="ms_burger_close">
	<label for="ms_burger"><svg viewBox="0 0 110 110" width="24" height="24">
	    <line x1="10" y1="10" x2="100" y2="100" stroke="#047bc2" stroke-width="20" />
	    <line x1="100" y1="10" x2="10" y2="100" stroke="#047bc2" stroke-width="20" />
	</svg></label>
      </div>
    </div>

    <div id="ms_navdrawer_content">
      <ul>
	
    <li><a href="/" >About</a></li>
    <li><a href="/posts/" class="active">Blog</a></li>
    <li><a href="/talks/" >Talks</a></li>
    <li><a href="/series/" >Series</a></li>

      </ul>
    </div>
  </nav>
</header>
<main>
      <div>
<h1 class="ms_title">Fixing the Nuki Opener smart intercom IOT device (on the BTicino SCS bus intercom system) (2020)</h1>

<div class="ms_meta">
  <div id="ms_date">published 2020-11-30, last modified 2023-01-22</div>
  
  
  <div>
    <a href="https://github.com/stapelberg/hugo/edit/master/content/posts/2020-11-30-scs-processing-microcontroller/index.markdown"><img src="/Bilder/pen-square-solid.svg" width="18" height="20" alt="Edit Icon" title="Suggest a change to this article"></a>
  </div>
  
</div>
<div class="Artikel" id="content">
  <style type="text/css">
    .TableOfContents > ul, .TableOfContents > ul > li > ul {
	list-style: none;
	margin: 0;
	padding: 0;
    }
    .TableOfContents > ul > li > ul {
	margin: 1em;
    }
    .TableOfContents li {
	margin-bottom: 1rem;
    }
  </style>
  <details class="ms_toc_details">
    <summary>Table of contents</summary>
    <nav class="TableOfContents">
  <ul>
    <li><a href="#prerequisites">Prerequisites</a>
      <ul>
        <li><a href="#scs-receive-circuit">SCS receive circuit</a></li>
        <li><a href="#scs-transmit-circuit">SCS transmit circuit</a></li>
        <li><a href="#scs-lab-setup">SCS lab setup</a></li>
        <li><a href="#micro-controller-choice">Micro Controller choice</a></li>
      </ul>
    </li>
    <li><a href="#signal-setup">Signal Setup</a></li>
    <li><a href="#micro-controller-firmware">Micro Controller firmware</a>
      <ul>
        <li><a href="#analog-comparator">Analog Comparator</a></li>
        <li><a href="#analog-comparator-modification">Analog Comparator Modification</a></li>
        <li><a href="#scs-rx-receive">SCS RX (receive)</a></li>
        <li><a href="#scs-tx-send">SCS TX (send)</a></li>
      </ul>
    </li>
    <li><a href="#it-works">It works!</a></li>
    <li><a href="#how-is-the-nuki-opener">How is the Nuki Opener?</a></li>
    <li><a href="#next-up">Next up</a></li>
    <li><a href="#appendix-project-journal">Appendix: Project Journal</a></li>
  </ul>
</nav>
  </details>
  <p>This post is the second article in a series of blog posts about the Nuki Opener
on the SCS bus intercom, <a href="/posts/2021-03-13-nuki-scs-series-overview/">see the Series
Overview</a>.</p>
<p>I recently bought a <a href="https://nuki.io/en/opener/">Nuki Opener, which “turns your existing intercom into a
smart door opener”</a>.</p>
<p>Unfortunately, I have had a lot of trouble getting it to work.</p>
<p>I finally got the device working by interjecting my own micro controller between
the intercom bus and the Nuki Opener, then driving the Nuki Opener in its
Analogue mode:</p>















<a href="https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-11-28-nuki-opener-filtered-featured.jpg"><img
  srcset="https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-11-28-nuki-opener-filtered-featured_hu46bb619362d02271ee9d454f3a246020_1421516_1200x0_resize_q75_box.jpg 2x,https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-11-28-nuki-opener-filtered-featured_hu46bb619362d02271ee9d454f3a246020_1421516_1800x0_resize_q75_box.jpg 3x"
  src="https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-11-28-nuki-opener-filtered-featured_hu46bb619362d02271ee9d454f3a246020_1421516_600x0_resize_q75_box.jpg"
  
  width="600"
  height="800"
  style="

border: 1px solid #000;

"
  
  loading="lazy"></a>



<p>The rest of this article outlines how this setup works at a high level.</p>
<aside class="admonition note">
  <div class="note-container">
    <div class="note-icon" style="width: 20px; height: 20px">
      <svg id="exclamation-icon" width="100%" height="100%" viewBox="0 0 24 24" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:1.41421;">
    <path d="M0,0L24,0L24,24L0,24L0,0Z" style="fill:none;"/>
    <g transform="matrix(1.2,0,0,1.2,-2.4,-2.4)">
        <path d="M12,2C6.48,2 2,6.48 2,12C2,17.52 6.48,22 12,22C17.52,22 22,17.52 22,12C22,6.48 17.52,2 12,2ZM13,17L11,17L11,15L13,15L13,17ZM13,13L11,13L11,7L13,7L13,13Z" style="fill-rule:nonzero;"/>
    </g>
</svg>

    </div>
    <div class="admonition-content"><p><strong>Warning:</strong> The SCS bus’s voltage is dangerously high!</p>
<p>I accidentally broke a Teensy and an intercom unit while working with the SCS
bus, which is specified at 27 Vdc, but my measurements show 28 volts. Please be
extra careful!</p>
</div>
  </div>
</aside>

<h2 id="prerequisites">Prerequisites</h2>
<p>For reliable interpretation and transmission of SCS bus data, we’ll need:</p>
<ol>
<li>
<p>SCS receive/transmit circuits. These can be prototyped on a breadboard if you
have the required diodes, transistors, resistors and capacitors.</p>
</li>
<li>
<p>A microcontroller with an Analog Comparator. If your microcontroller has one,
you’ll find a corresponding section in the datasheet. This function is
sometimes abbreviated to <code>CMP</code> or <code>AC</code>, or might be part of a larger
Analog/Digital Converter (<code>ADC</code>).</p>
</li>
<li>
<p>A UART (serial) decoder. Most microcontrollers have at least one UART, but if
you don’t have one available for whichever reason, you could use a software
UART implementation, too.</p>
</li>
</ol>
<h3 id="scs-receive-circuit">SCS receive circuit</h3>




<a href="https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-11-29-scs-rx.svg"><img
  src="https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-11-29-scs-rx.svg"
  alt="SCS receive circuit" title="SCS receive circuit"
  style="

border: 1px solid #000;

margin-right: 1rem"
  
  align="left"
  
  loading="lazy"></a>


<p>An R-C network, directly connected to the SCS bus, is used for incoming signal
conditioning.</p>
<p>The resistor values have been chosen to divide the voltage of the input signal
from 28V down to approx. 2V, i.e. well within the 0-3.3V range for modern
microcontroller GPIO pins.</p>
<p>A zener diode limits the 28V level to 3.3V, which should be safe for most
microcontrollers.</p>
<p>Simulation: <a href="https://tinyurl.com/yxhrkejn">https://tinyurl.com/yxhrkejn</a></p>
<br clear="all">
<h3 id="scs-transmit-circuit">SCS transmit circuit</h3>




<a href="https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-11-29-scs-tx.svg"><img
  src="https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-11-29-scs-tx.svg"
  alt="SCS transmit circuit" title="SCS transmit circuit"
  style="

border: 1px solid #000;

margin-right: 1rem"
  
  align="left"
  
  loading="lazy"></a>


<p>We directly connect the gate of a mosfet transistor to a GPIO pin of our
microcontroller, so that when the microcontroller drives the pin high, we use
the 100Ω resistor to attach a load to the SCS bus.</p>
<p>For comparison, the KNX bus, which is similar to the SCS bus, uses a 68Ω
resistor here.</p>
<p>Simulation: <a href="https://tinyurl.com/y6nv4yg7">https://tinyurl.com/y6nv4yg7</a></p>
<br clear="all">
<h3 id="scs-lab-setup">SCS lab setup</h3>
<p>Use a lab power supply to generate 28V DC. I’m using the <a href="https://www.galaxus.ch/de/s1/product/velleman-labornetzgeraet-labornetzgeraet-5779537">Velleman LABPS3005SM</a> because it was in stock at Galaxus, but any power supply rated for at least 30V DC will do.</p>
<p>As <a href="https://www.open-homeautomation.com/2016/05/11/a-minimal-knx-setup/">the DIY home automation blog entry “A minimal KNX setup”</a> describes, you’ll need to place a 47Ω resistor between the power line and your components.</p>
<p>Afterwards, just connect your components to the bus. The supply/ground line of a <a href="https://en.wikipedia.org/wiki/Breadboard">breadboard</a> will work nicely.</p>















<a href="https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-11-29-scs-lab-setup.jpg"><img
  srcset="https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-11-29-scs-lab-setup_huf43c3b3dca98c428537fa46c6d1931d3_1264545_1200x0_resize_q75_box.jpg 2x,https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-11-29-scs-lab-setup_huf43c3b3dca98c428537fa46c6d1931d3_1264545_1800x0_resize_q75_box.jpg 3x"
  src="https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-11-29-scs-lab-setup_huf43c3b3dca98c428537fa46c6d1931d3_1264545_600x0_resize_q75_box.jpg"
  alt="SCS lab setup" title="SCS lab setup"
  width="600"
  height="450"
  style="

border: 1px solid #000;

"
  
  loading="lazy"></a>



<h3 id="micro-controller-choice">Micro Controller choice</h3>
<p>In this blog post, I’m using a <a href="https://www.pjrc.com/store/teensy40.html">Teensy
4</a> development board that is widely
available for ≈20 USD:</p>















<a href="https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-11-29-teensy4.jpg"><img
  srcset="https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-11-29-teensy4_hu855bbe0a9c47ac557e5b09db74fa3b06_1510905_1200x0_resize_q75_box.jpg 2x,https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-11-29-teensy4_hu855bbe0a9c47ac557e5b09db74fa3b06_1510905_1800x0_resize_q75_box.jpg 3x"
  src="https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-11-29-teensy4_hu855bbe0a9c47ac557e5b09db74fa3b06_1510905_600x0_resize_q75_box.jpg"
  alt="Teensy 4" title="Teensy 4"
  width="600"
  height="450"
  style="

border: 1px solid #000;

"
  
  loading="lazy"></a>



<p>With its 600 MHz, the Teensy 4 has enough sheer clock frequency to allow for
sloppier coding while still achieving high quality input/output.</p>
<p>The teensy tiny form factor (3.5 x 1.7 cm) works well for this project and will
allow me to store the microcontroller in an existing intercom case.</p>
<p>The <strong>biggest downside is that NXP’s own MCUXpresso IDE cannot target the
Teensy 4</strong>!</p>
<p>The only officially supported development environment for the Teensy 4 is
Teensyduino, which is a board support package for the Arduino IDE. Having
Arduino support is great, but let’s compare:</p>
<p>I also have NXP’s <a href="https://www.nxp.com/design/development-boards/i-mx-evaluation-and-development-boards/mimxrt1060-evk-i-mx-rt1060-evaluation-kit:MIMXRT1060-EVK?&amp;&amp;tid=vanMIMXRT1060-EVK">MIMXRT1060-EVK eval
kit</a>,
which uses the same i.MX RT1060 micro controller family as the Teensy 4, but is
much larger and comes with all the bells and whistles; notably:</p>
<ol>
<li>The MCUXpresso IDE works with the eval kit’s built-in debugger out of the box!
Being able to inspect a stack trace, set breakpoints and look at register
contents are invaluable tools when doing micro controller development.</li>
<li>The MCUXpresso IDE comes with convenient graphical Pin and Clock config
tools. Setting a pin’s alternate function becomes a few clicks instead of
hours of fumbling around.</li>
<li>The NXP SDK contains a number of drivers and examples that are tested on the
eval kit. That makes it really easy to get started!</li>
</ol>
<p>Each of these points is very attractive on their own, but together they make the
whole experience so different!</p>
<p>Being able to deploy to the Teensy from MCUXpresso would be a killer feature! So
many NXP SDK examples would suddenly become available, filling the Teensy
community’s gaps.</p>
<h2 id="signal-setup">Signal Setup</h2>
<p>On a high level, this is how we are going to connect the various signals:</p>
<p>Step 1. We start with the SCS intercom bus signal (28V high, 22V low):</p>















<a href="https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-10-06-scs-bus.jpg"><img
  srcset="https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-10-06-scs-bus_hucbd1cf38e2c23c2f6ccc4d43d53e5fa3_262726_1200x0_resize_q75_box.jpg 2x,https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-10-06-scs-bus_hucbd1cf38e2c23c2f6ccc4d43d53e5fa3_262726_1800x0_resize_q75_box.jpg 3x"
  src="https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-10-06-scs-bus_hucbd1cf38e2c23c2f6ccc4d43d53e5fa3_262726_600x0_resize_q75_box.jpg"
  
  width="600"
  height="160"
  style="

border: 1px solid #000;

"
  
  loading="lazy"></a>



<p>Step 2. Our SCS receive circuit takes the bus signal and divides it down to 2V:</p>















<a href="https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-11-25-scs-rx.jpg"><img
  srcset="https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-11-25-scs-rx_huda44e0426bfee0fc7f10a0aefe6154d7_193510_1200x0_resize_q75_box.jpg 2x,https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-11-25-scs-rx_huda44e0426bfee0fc7f10a0aefe6154d7_193510_1800x0_resize_q75_box.jpg 3x"
  src="https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-11-25-scs-rx_huda44e0426bfee0fc7f10a0aefe6154d7_193510_600x0_resize_q75_box.jpg"
  alt="voltage-divided SCS signal" title="voltage-divided SCS signal"
  width="600"
  height="447"
  style="

border: 1px solid #000;

"
  
  loading="lazy"></a>



<p>Step 3. We convert the voltage-divided analog signal into a digital <code>SCSRXOUT</code> signal:</p>















<a href="https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-11-25-acmp-out.jpg"><img
  srcset="https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-11-25-acmp-out_hud21e06aec62e4c2328f97cadeb89169a_202741_1200x0_resize_q75_box.jpg 2x,https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-11-25-acmp-out_hud21e06aec62e4c2328f97cadeb89169a_202741_1800x0_resize_q75_box.jpg 3x"
  src="https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-11-25-acmp-out_hud21e06aec62e4c2328f97cadeb89169a_202741_600x0_resize_q75_box.jpg"
  alt="Analog Comparator output signal" title="Analog Comparator output signal"
  width="600"
  height="104"
  style="

border: 1px solid #000;

"
  
  loading="lazy"></a>



<p>Step 4. We modify our <code>SCSRXOUT</code> signal so that it can be sampled at 50%:</p>















<a href="https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-11-26-modified-scs.jpg"><img
  srcset="https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-11-26-modified-scs_huf442b516588f4a97de6b824c24ce97c9_400929_1200x0_resize_q75_box.jpg 2x,https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-11-26-modified-scs_huf442b516588f4a97de6b824c24ce97c9_400929_1800x0_resize_q75_box.jpg 3x"
  src="https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-11-26-modified-scs_huf442b516588f4a97de6b824c24ce97c9_400929_600x0_resize_q75_box.jpg"
  alt="modified SCS signal" title="modified SCS signal"
  width="600"
  height="422"
  style="

border: 1px solid #000;

"
  
  loading="lazy"></a>



<p>Step 5. We decode the signal using our micro controller’s UART:</p>















<a href="https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-11-26-teensy-uart-scs-hex.jpg"><img
  srcset="https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-11-26-teensy-uart-scs-hex_hu39435dced393ae623f524c34c9d5a9f1_269597_1200x0_resize_q75_box.jpg 2x,https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-11-26-teensy-uart-scs-hex_hu39435dced393ae623f524c34c9d5a9f1_269597_1800x0_resize_q75_box.jpg 3x"
  src="https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-11-26-teensy-uart-scs-hex_hu39435dced393ae623f524c34c9d5a9f1_269597_600x0_resize_q75_box.jpg"
  alt="Teensy 4 UART decodes SCS" title="Teensy 4 UART decodes SCS"
  width="600"
  height="424"
  style="

border: 1px solid #000;

"
  
  loading="lazy"></a>



<h2 id="micro-controller-firmware">Micro Controller firmware</h2>
<p>Once I complete the next revision of the SCS interface PCB, I plan to release
all design files, schematics, sources, etc. in full.</p>
<p>Until then, the following sections describe how the most important parts work,
but skip over the implementation-specific glue code that wires everything
together.</p>
<h3 id="analog-comparator">Analog Comparator</h3>
<p>The Analog Comparator in our microcontroller lets us know whether a voltage is
above or below a configured threshold voltage by raising an interrupt. A good
threshold is 1.65V in my case.</p>
<p>In response to the voltage change, we set GPIO pin 15 to a digital high (3.3V) or
low (0V) level:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#007020;font-weight:bold">volatile</span> <span style="color:#902000">uint32_t</span> cmpflags;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#60a0b0;font-style:italic">// ISR (Interrupt Service Routine), called by the Analog Comparator:
</span></span></span><span style="display:flex;"><span><span style="color:#60a0b0;font-style:italic"></span><span style="color:#902000">void</span> <span style="color:#06287e">acmp1_isr</span>() {
</span></span><span style="display:flex;"><span>  cmpflags <span style="color:#666">=</span> CMP1_SCR;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  { <span style="color:#60a0b0;font-style:italic">// clear interrupt status flags:
</span></span></span><span style="display:flex;"><span><span style="color:#60a0b0;font-style:italic"></span>    <span style="color:#902000">uint8_t</span> scr <span style="color:#666">=</span> (CMP1_SCR <span style="color:#666">&amp;</span> <span style="color:#666">~</span>(CMP_SCR_CFR_MASK <span style="color:#666">|</span> CMP_SCR_CFF_MASK));
</span></span><span style="display:flex;"><span>    CMP1_SCR <span style="color:#666">=</span> scr <span style="color:#666">|</span> CMP_SCR_CFR_MASK <span style="color:#666">|</span> CMP_SCR_CFF_MASK;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#007020;font-weight:bold">if</span> (cmpflags <span style="color:#666">&amp;</span> CMP_SCR_CFR_MASK) {
</span></span><span style="display:flex;"><span>    <span style="color:#60a0b0;font-style:italic">// See below! This line will be modified:
</span></span></span><span style="display:flex;"><span><span style="color:#60a0b0;font-style:italic"></span>    <span style="color:#06287e">digitalWrite</span>(<span style="color:#40a070">15</span>, HIGH);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#007020;font-weight:bold">if</span> (cmpflags <span style="color:#666">&amp;</span> CMP_SCR_CFF_MASK) {
</span></span><span style="display:flex;"><span>    <span style="color:#06287e">digitalWrite</span>(<span style="color:#40a070">15</span>, LOW);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This signal can easily be verified by attaching an oscilloscope probe each to
the <code>SCSRX</code> voltage-regulated bus signal input and to the <code>SCSRXOUT</code> GPIO pin
output:</p>















<a href="https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-11-25-acmp-out.jpg"><img
  srcset="https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-11-25-acmp-out_hud21e06aec62e4c2328f97cadeb89169a_202741_1200x0_resize_q75_box.jpg 2x,https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-11-25-acmp-out_hud21e06aec62e4c2328f97cadeb89169a_202741_1800x0_resize_q75_box.jpg 3x"
  src="https://michael.stapelberg.ch/posts/2020-11-30-scs-processing-microcontroller/2020-11-25-acmp-out_hud21e06aec62e4c2328f97cadeb89169a_202741_600x0_resize_q75_box.jpg"
  alt="Analog Comparator output signal" title="Analog Comparator output signal"
  width="600"
  height="104"
  style="

border: 1px solid #000;

"
  
  loading="lazy"></a>



<h3 id="analog-comparator-modification">Analog Comparator Modification</h3>
<p>There is one crucial difference between SCS and UART:</p>
<p>To transmit a 0 (or start bit):</p>
<ul>
<li>SCS is low 34μs, then high 70μs</li>
<li>UART is low the entire 104μs</li>
</ul>
<p>UART implementations typically sample at 50%, the middle of the bit period.</p>
<p>For SCS, we would need to sample at 20%, because the signal returns to high so
quickly.</p>
<p>While setting a custom sample point is <em>possible</em> in
e.g. <a href="https://sigrok.org/">sigrok</a>’s UART decoder, neither software nor hardware
serial implementations on micro controllers typically support it.</p>
<p>On a micro controller it is much easier to just modify the signal so that it can
be sampled at 50%.</p>
<p>In practical terms, this means modifying the <code>acmp1_isr</code> function to return to
high later than the Analog Comparator indicates:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#007020;font-weight:bold">volatile</span> <span style="color:#902000">uint32_t</span> cmpflags;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#60a0b0;font-style:italic">// ISR (Interrupt Service Routine), called by the Analog Comparator:
</span></span></span><span style="display:flex;"><span><span style="color:#60a0b0;font-style:italic"></span><span style="color:#902000">void</span> <span style="color:#06287e">acmp1_isr</span>() {
</span></span><span style="display:flex;"><span>  cmpflags <span style="color:#666">=</span> CMP1_SCR;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  { <span style="color:#60a0b0;font-style:italic">// clear interrupt status flags:
</span></span></span><span style="display:flex;"><span><span style="color:#60a0b0;font-style:italic"></span>    <span style="color:#902000">uint8_t</span> scr <span style="color:#666">=</span> (CMP1_SCR <span style="color:#666">&amp;</span> <span style="color:#666">~</span>(CMP_SCR_CFR_MASK <span style="color:#666">|</span> CMP_SCR_CFF_MASK));
</span></span><span style="display:flex;"><span>    CMP1_SCR <span style="color:#666">=</span> scr <span style="color:#666">|</span> CMP_SCR_CFR_MASK <span style="color:#666">|</span> CMP_SCR_CFF_MASK;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#007020;font-weight:bold">if</span> (cmpflags <span style="color:#666">&amp;</span> CMP_SCR_CFR_MASK) {
</span></span><span style="display:flex;"><span>    <span style="color:#60a0b0;font-style:italic">// Instead of setting our output pin high immediately,
</span></span></span><span style="display:flex;"><span><span style="color:#60a0b0;font-style:italic"></span>    <span style="color:#60a0b0;font-style:italic">// we delay going up by approx. 40us,
</span></span></span><span style="display:flex;"><span><span style="color:#60a0b0;font-style:italic"></span>    <span style="color:#60a0b0;font-style:italic">// turning the SCS signal into a UART signal:
</span></span></span><span style="display:flex;"><span><span style="color:#60a0b0;font-style:italic"></span>    <span style="color:#06287e">delayMicroseconds</span>(<span style="color:#40a070">40</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#06287e">digitalWrite</span>(<span style="color:#40a070">15</span>, HIGH);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#007020;font-weight:bold">if</span> (cmpflags <span style="color:#666">&amp;</span> CMP_SCR_CFF_MASK) {
</span></span><span style="display:flex;"><span>    <span style="color:#06287e">digitalWrite</span>(<span style="color:#40a070">15</span>, LOW);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>You can now read this signal using your laptop and a USB-to-serial adapter!</p>
<p>On a micro controller, we now feed this signal back into a UART decoder. For
prototyping, this can literally mean a jumper wire connecting the output GPIO
pin with a serial RX pin. Some micro controllers also support internal wiring of
peripherals, allowing you to get rid of that cable.</p>
<h3 id="scs-rx-receive">SCS RX (receive)</h3>
<p>With the SCS intercom bus signal bytes now available through the UART decoder,
we can design a streaming SCS decoder. The decoder self-synchronizes and skips
invalid SCS telegrams by checking their checksum. We start with a ring buffer
and a convenience working copy:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>constexpr <span style="color:#902000">int</span> telegramLen <span style="color:#666">=</span> <span style="color:#40a070">7</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007020;font-weight:bold">typedef</span> <span style="color:#007020;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#60a0b0;font-style:italic">// circular buffer for incoming bytes, indexed using cur
</span></span></span><span style="display:flex;"><span><span style="color:#60a0b0;font-style:italic"></span>  <span style="color:#902000">uint8_t</span> buf[telegramLen];
</span></span><span style="display:flex;"><span>  <span style="color:#902000">int</span> cur;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#902000">uint8_t</span> tbuf[telegramLen];
</span></span><span style="display:flex;"><span>} scsfilter;
</span></span></code></pre></div><p>Each byte we receive from the UART, we store in our ring buffer:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#902000">void</span> <span style="color:#06287e">sf_WriteByte</span>(scsfilter <span style="color:#666">*</span>sf, <span style="color:#902000">uint8_t</span> b) {
</span></span><span style="display:flex;"><span>  sf<span style="color:#666">-&gt;</span>buf[sf<span style="color:#666">-&gt;</span>cur] <span style="color:#666">=</span> b;
</span></span><span style="display:flex;"><span>  sf<span style="color:#666">-&gt;</span>cur <span style="color:#666">=</span> (sf<span style="color:#666">-&gt;</span>cur <span style="color:#666">+</span> <span style="color:#40a070">1</span>) <span style="color:#666">%</span> telegramLen;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>After every byte, we can check if the ring buffer decodes to a valid ring signal
SCS bus telegram:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#902000">bool</span> <span style="color:#06287e">sf_completeAndValid</span>(scsfilter <span style="color:#666">*</span>sf) {
</span></span><span style="display:flex;"><span>  <span style="color:#007020;font-weight:bold">const</span> <span style="color:#902000">uint8_t</span> prev <span style="color:#666">=</span> sf<span style="color:#666">-&gt;</span>buf[(sf<span style="color:#666">-&gt;</span>cur<span style="color:#666">+</span>(telegramLen<span style="color:#666">-</span><span style="color:#40a070">1</span>))<span style="color:#666">%</span>telegramLen];
</span></span><span style="display:flex;"><span>  <span style="color:#007020;font-weight:bold">if</span> (prev <span style="color:#666">!=</span> <span style="color:#40a070">0xa3</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#007020;font-weight:bold">return</span> <span style="color:#007020">false</span>; <span style="color:#60a0b0;font-style:italic">// incomplete: previous byte not a telegram termination
</span></span></span><span style="display:flex;"><span><span style="color:#60a0b0;font-style:italic"></span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#60a0b0;font-style:italic">// Copy the whole telegram into tbuf; makes working with it easier:
</span></span></span><span style="display:flex;"><span><span style="color:#60a0b0;font-style:italic"></span>  <span style="color:#007020;font-weight:bold">for</span> (<span style="color:#902000">int</span> i <span style="color:#666">=</span> <span style="color:#40a070">0</span>; i <span style="color:#666">&lt;</span> telegramLen; i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>    sf<span style="color:#666">-&gt;</span>tbuf[i] <span style="color:#666">=</span> sf<span style="color:#666">-&gt;</span>buf[(sf<span style="color:#666">-&gt;</span>cur<span style="color:#666">+</span>i)<span style="color:#666">%</span>telegramLen];
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#007020;font-weight:bold">const</span> <span style="color:#902000">uint8_t</span> stored <span style="color:#666">=</span> sf<span style="color:#666">-&gt;</span>tbuf[<span style="color:#40a070">5</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#007020;font-weight:bold">const</span> <span style="color:#902000">uint8_t</span> computed <span style="color:#666">=</span> sf<span style="color:#666">-&gt;</span>tbuf[<span style="color:#40a070">1</span>] <span style="color:#666">^</span>
</span></span><span style="display:flex;"><span>    sf<span style="color:#666">-&gt;</span>tbuf[<span style="color:#40a070">2</span>] <span style="color:#666">^</span>
</span></span><span style="display:flex;"><span>	sf<span style="color:#666">-&gt;</span>tbuf[<span style="color:#40a070">3</span>] <span style="color:#666">^</span>
</span></span><span style="display:flex;"><span>	sf<span style="color:#666">-&gt;</span>tbuf[<span style="color:#40a070">4</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#007020;font-weight:bold">if</span> (stored <span style="color:#666">!=</span> computed) {
</span></span><span style="display:flex;"><span>    <span style="color:#007020;font-weight:bold">return</span> <span style="color:#007020">false</span>; <span style="color:#60a0b0;font-style:italic">// corrupt? checksum mismatch
</span></span></span><span style="display:flex;"><span><span style="color:#60a0b0;font-style:italic"></span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#007020;font-weight:bold">return</span> <span style="color:#007020">true</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#902000">int</span> <span style="color:#06287e">sf_ringForApartment</span>(scsfilter <span style="color:#666">*</span>sf) {
</span></span><span style="display:flex;"><span>  <span style="color:#007020;font-weight:bold">if</span> (<span style="color:#666">!</span><span style="color:#06287e">sf_completeAndValid</span>(sf)) {
</span></span><span style="display:flex;"><span>    <span style="color:#007020;font-weight:bold">return</span> <span style="color:#666">-</span><span style="color:#40a070">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#007020;font-weight:bold">if</span> (sf<span style="color:#666">-&gt;</span>tbuf[<span style="color:#40a070">3</span>] <span style="color:#666">!=</span> <span style="color:#40a070">0x60</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#007020;font-weight:bold">return</span> <span style="color:#666">-</span><span style="color:#40a070">1</span>; <span style="color:#60a0b0;font-style:italic">// not a ring command
</span></span></span><span style="display:flex;"><span><span style="color:#60a0b0;font-style:italic"></span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#007020;font-weight:bold">if</span> (sf<span style="color:#666">-&gt;</span>tbuf[<span style="color:#40a070">1</span>] <span style="color:#666">!=</span> <span style="color:#40a070">0x91</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#007020;font-weight:bold">return</span> <span style="color:#666">-</span><span style="color:#40a070">1</span>; <span style="color:#60a0b0;font-style:italic">// not sent by the intercom house station
</span></span></span><span style="display:flex;"><span><span style="color:#60a0b0;font-style:italic"></span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#007020;font-weight:bold">return</span> (<span style="color:#902000">int</span>)(sf<span style="color:#666">-&gt;</span>tbuf[<span style="color:#40a070">2</span>]); <span style="color:#60a0b0;font-style:italic">// apartment id
</span></span></span><span style="display:flex;"><span><span style="color:#60a0b0;font-style:italic"></span>}
</span></span></code></pre></div><h3 id="scs-tx-send">SCS TX (send)</h3>
<p>Conceptually, writing serial data to a GPIO output from software is done with
<a href="https://www.arduino.cc/en/Reference/SoftwareSerial">e.g. the Arduino SoftwareSerial
library</a>, but there are
plenty of implementations for different micro controllers. This technique is
also sometimes called <a href="https://en.wikipedia.org/wiki/Bit_banging">“Bit banging”</a>.</p>
<p>I started with the <a href="https://github.com/PaulStoffregen/SoftwareSerial/blob/63f9b1aae6564d301d7ba31261d1f2390e2a7359/SoftwareSerial.cpp#L218">the Teensy <code>SoftwareSerial::write</code>
implementation</a>
and modified it to:</p>
<ol>
<li>
<p>Invert the output to drive the <a href="#scs-transmit-circuit">SCS transmit circuit’s Mosfet
transistor</a> gate, i.e. low on idle and high on
transmitting a 0 bit.</p>
</li>
<li>
<p>Return to idle 70μs earlier than the signal would, i.e. after ≈34μs already.</p>
</li>
</ol>
<p>The modified <code>write</code> function looks like this:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#007020">#define V27 LOW
</span></span></span><span style="display:flex;"><span><span style="color:#007020">#define V22 HIGH
</span></span></span><span style="display:flex;"><span><span style="color:#007020"></span>
</span></span><span style="display:flex;"><span><span style="color:#007020">#define scs0() do { \
</span></span></span><span style="display:flex;"><span><span style="color:#007020">  while (ARM_DWT_CYCCNT - begin_cycle &lt; (target-43750</span><span style="color:#60a0b0;font-style:italic">/*70us*/</span><span style="color:#007020">)) ; \
</span></span></span><span style="display:flex;"><span><span style="color:#007020">  digitalWriteFast(11, V27); \
</span></span></span><span style="display:flex;"><span><span style="color:#007020">} while (0)
</span></span></span><span style="display:flex;"><span><span style="color:#007020"></span>
</span></span><span style="display:flex;"><span><span style="color:#902000">size_t</span> SCSSerial<span style="color:#666">::</span><span style="color:#06287e">write</span>(<span style="color:#902000">uint8_t</span> b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  elapsedMicros elapsed;
</span></span><span style="display:flex;"><span>  <span style="color:#902000">uint32_t</span> target;
</span></span><span style="display:flex;"><span>  <span style="color:#902000">uint8_t</span> mask;
</span></span><span style="display:flex;"><span>  <span style="color:#902000">uint32_t</span> begin_cycle;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  ARM_DEMCR <span style="color:#666">|=</span> ARM_DEMCR_TRCENA;
</span></span><span style="display:flex;"><span>  ARM_DWT_CTRL <span style="color:#666">|=</span> ARM_DWT_CTRL_CYCCNTENA;
</span></span><span style="display:flex;"><span>  ARM_DWT_CYCCNT <span style="color:#666">=</span> <span style="color:#40a070">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#60a0b0;font-style:italic">// start bit
</span></span></span><span style="display:flex;"><span><span style="color:#60a0b0;font-style:italic"></span>  target <span style="color:#666">=</span> cycles_per_bit;
</span></span><span style="display:flex;"><span>  <span style="color:#06287e">noInterrupts</span>();
</span></span><span style="display:flex;"><span>  begin_cycle <span style="color:#666">=</span> ARM_DWT_CYCCNT;
</span></span><span style="display:flex;"><span>  <span style="color:#06287e">digitalWriteFast</span>(<span style="color:#40a070">11</span>, V22);
</span></span><span style="display:flex;"><span>  <span style="color:#06287e">scs0</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#06287e">wait_for_target</span>(begin_cycle, target);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#60a0b0;font-style:italic">// 8 data bits
</span></span></span><span style="display:flex;"><span><span style="color:#60a0b0;font-style:italic"></span>  <span style="color:#007020;font-weight:bold">for</span> (mask <span style="color:#666">=</span> <span style="color:#40a070">1</span>; mask; mask <span style="color:#666">&lt;&lt;=</span> <span style="color:#40a070">1</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#007020;font-weight:bold">if</span> (b<span style="color:#666">&amp;</span>mask) {
</span></span><span style="display:flex;"><span>      <span style="color:#06287e">digitalWriteFast</span>(<span style="color:#40a070">11</span>, V27);
</span></span><span style="display:flex;"><span>    } <span style="color:#007020;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#06287e">digitalWriteFast</span>(<span style="color:#40a070">11</span>, V22);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    target <span style="color:#666">+=</span> cycles_per_bit;
</span></span><span style="display:flex;"><span>    <span style="color:#06287e">scs0</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#06287e">wait_for_target</span>(begin_cycle, target);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#60a0b0;font-style:italic">// stop bit
</span></span></span><span style="display:flex;"><span><span style="color:#60a0b0;font-style:italic"></span>  <span style="color:#06287e">digitalWriteFast</span>(<span style="color:#40a070">11</span>, V27);
</span></span><span style="display:flex;"><span>  <span style="color:#06287e">interrupts</span>();
</span></span><span style="display:flex;"><span>  target <span style="color:#666">+=</span> cycles_per_bit;
</span></span><span style="display:flex;"><span>  <span style="color:#06287e">scs0</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#007020;font-weight:bold">while</span> (ARM_DWT_CYCCNT <span style="color:#666">-</span> begin_cycle <span style="color:#666">&lt;</span> target) ; <span style="color:#60a0b0;font-style:italic">// wait
</span></span></span><span style="display:flex;"><span><span style="color:#60a0b0;font-style:italic"></span>  <span style="color:#007020;font-weight:bold">return</span> <span style="color:#40a070">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="it-works">It works!</h2>
<p>With the approach described above, I now have a micro controller that recognizes
doorbell rings for my apartment and ignores doorbell rings for my neighbors. The
micro controller can unlock the door, too, and both features are available
through the Nuki Opener.</p>
<h2 id="how-is-the-nuki-opener">How is the Nuki Opener?</h2>
<p>It took over 2 months before I saw the Nuki Opener working correctly for the
first time.</p>
<p>I really hope the Nuki developers can work with what I described above and
improve their product’s reliability for all customers with an SCS intercom
system!</p>
<p>The device itself seems useful and usable, but time will tell how reliable it
turns out in practice. I think I noticed push notifications when the door rang
coming in rather late (many seconds later).</p>
<p>I’ll keep an eye on this and explore the various Nuki APIs more.</p>
<p><strong>Update (January 2023)</strong>: The doorbell push notification typically arrives
within seconds of the doorbell ring, but sometimes there is a noticeable delay
of tens of seconds — definitely long enough for the delivery person to lose
patience. I’m glad I have my <a href="/posts/2021-03-13-smart-intercom-backpack/">MQTT-based
solution</a> which has a &lt;1s delay.</p>
<h2 id="next-up">Next up</h2>
<p>The third article in this series is <a href="/posts/2021-03-13-smart-intercom-backpack/">Make your intercom smarter with an MQTT
backpack</a>.</p>
<h2 id="appendix-project-journal">Appendix: Project Journal</h2>
<ul>
<li>2020-09-26: I buy a Nuki Opener (Nuki Opener #1), but despite connecting it correctly, it never successfully opens the door. I start learning about <a href="https://en.wikipedia.org/wiki/Bus_SCS">the SCS home automation bus system that our intercom uses</a>.</li>
<li>2020-09-28: I publish an <a href="/posts/2020-09-28-nuki-scs-bticino-decoding/">SCS bus decoder for sigrok</a> and contact the Nuki Support.</li>
<li>2020-10-15: I buy another Nuki Opener (Nuki Opener #2) to test their old firmware version, because downgrading firmware versions is impossible. Opener #2 actually opens the door, so I assume we are dealing with a firmware problem [turns out incorrect later].</li>
<li>2020-10-16: I publish a detailed <a href="/posts/2020-10-16-nuki-bug-writeup/">analysis of the Nuki Opener not sending the correct signal</a> for the Nuki developers to go through.</li>
<li>2020-11-03: I update my new Nuki Opener #2 to the latest firmware and realize that my old Nuki Opener #1 most likely just has some sort of hardware defect. However, Opener #2 has trouble detecting the ring signal: either it doesn’t detect any rings at all, or it detects all rings, including those for my neighbors!</li>
<li>2020-11-16: In their 13th (!) email reply, Nuki Support confirms that the Opener firmware is capturing and matching the incoming ring signal, if I understand their developers correctly.</li>
<li>2020-11-18: I suggest to Nuki developers (via Nuki Support) to decode the SCS signal with a UART decoder instead of comparing waveforms. This should be a lot more reliable!</li>
<li>2020-11-23: My self-designed SCS receiver/transmitter/power supply PCB arrives. The schematics are based on existing SCS DIY work, but I created my own KiCad files because I was only interested in the SCS bus interface, not the PIC microcontroller they used.</li>
<li>2020-11-25: Working on the intercom, I assume some wire touched an unlucky spot, and my BTicino intercom went up in smoke. We enabled the Nuki Opener’s ring sound and started using it as our main door bell. This meant we now started hearing the ring sound for (some) of our neighbors as well.</li>
<li>2020-11-26: My Teensy 4 microcontroller <a href="https://twitter.com/zekjur/status/1332021864206626817">successfully decodes the SCS bus signal with its Analog Comparator and UART decoder</a>.</li>
<li>2020-11-28: My Teensy 4 microcontroller <a href="https://twitter.com/zekjur/status/1332740378907250693">is deployed to filter the SCS bus ring signal and drive the Nuki Opener in analogue mode</a>.</li>
</ul>
<div id="bmc">
  <p>
    I run a blog since 2005, spreading knowledge and experience for almost 20 years! :)
  </p>
  <p>
    If you want to support my work, you
    can <a href="https://www.buymeacoffee.com/stapelberg">buy me a coffee</a>.
  </p>
  <p>
    Thank you for your support! ❤️
  </p>
</div>

</div>

      </div>
<div id="ms_toc">
  <div>
    <strong>Table Of Contents</strong>

    <nav class="TableOfContents">
  <ul>
    <li><a href="#prerequisites">Prerequisites</a>
      <ul>
        <li><a href="#scs-receive-circuit">SCS receive circuit</a></li>
        <li><a href="#scs-transmit-circuit">SCS transmit circuit</a></li>
        <li><a href="#scs-lab-setup">SCS lab setup</a></li>
        <li><a href="#micro-controller-choice">Micro Controller choice</a></li>
      </ul>
    </li>
    <li><a href="#signal-setup">Signal Setup</a></li>
    <li><a href="#micro-controller-firmware">Micro Controller firmware</a>
      <ul>
        <li><a href="#analog-comparator">Analog Comparator</a></li>
        <li><a href="#analog-comparator-modification">Analog Comparator Modification</a></li>
        <li><a href="#scs-rx-receive">SCS RX (receive)</a></li>
        <li><a href="#scs-tx-send">SCS TX (send)</a></li>
      </ul>
    </li>
    <li><a href="#it-works">It works!</a></li>
    <li><a href="#how-is-the-nuki-opener">How is the Nuki Opener?</a></li>
    <li><a href="#next-up">Next up</a></li>
    <li><a href="#appendix-project-journal">Appendix: Project Journal</a></li>
  </ul>
</nav>
  </div>
</div>

    </main><div id="ms_footer">
  © 2024 Michael Stapelberg • all articles under <a href="https://creativecommons.org/licenses/by/4.0/">Creative Commons CC-BY license</a>
</div>
</body>
</html>
